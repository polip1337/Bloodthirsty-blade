<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cursed Sword Idle</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<!-- Modals -->
<div id="raceSelectionModal" class="modal">
    <h3>Choose Your Wielder's Race</h3>
    <div id="raceOptions"></div>
    <button onclick="onModalClose('raceSelectionModal')">Close</button>
</div>
<div id="unlocksModal" class="modal">
    <h3>Next Unlocks</h3>
    <div id="unlockList"></div>
    <button onclick="onModalClose('unlocksModal')">Close</button>
</div>
<div id="statsModal" class="modal">
    <h3>Game Statistics</h3>
    <div id="statisticsContent"></div>
    <button onclick="onModalClose('statsModal')">Close</button>
</div>
<div id="optionsModal" class="modal">
    <h3>Game Options</h3>
    <textarea id="saveData" rows="5"></textarea>
    <button onclick="exportSave()">Export Save</button>
    <button onclick="importSave()">Import Save</button>
    <button onclick="onModalClose('optionsModal')">Close</button>
</div>
<div id="storyModal" class="modal">
    <h3>Sword's Legacy</h3>
    <div id="storyContent"></div>
    <button onclick="onModalClose('storyModal')">Close</button>
</div>
<div id="changelogModal" class="modal">
    <h3>Changelog</h3>
    <div id="changelogContent"></div>
    <button onclick="onModalClose('changelogModal')">Close</button>
</div>
<div id="levelUpModal" class="modal">
    <h3>Level Up!</h3>
    <p>Current Stats:</p>
    <div id="currentStatsDisplay"></div>
    <p id="statPointsInfo"></p>
    <p>Choose a stat to improve:</p>
    <div class="stat-choice tooltip" onclick="allocatePoint('strength')">
        [+] Strength
        <span class="tooltiptext">Increase physical attack power</span>
    </div>
    <div class="stat-choice tooltip" onclick="allocatePoint('swordfighting')">
        [+] Swordfighting
        <span class="tooltiptext">Enhance defensive capabilities</span>
    </div>
    <div class="stat-choice tooltip" onclick="allocatePoint('endurance')">
        [+] Endurance
        <span class="tooltiptext">Increase maximum health</span>
    </div>
    <div class="stat-choice tooltip" onclick="allocatePoint('willpower')">
        [+] Willpower
        <span class="tooltiptext">Resist sword's control but gain better bonuses</span>
    </div>
</div>
<div id="wielderDeathModal" class="modal">
    <h3>Wielder Death</h3>
    <p id="wielderDeathMessage"></p>
    <p>You must select a new wielder.</p>
    <button onclick="showRaceSelection()">Select New Wielder</button>
</div>
<div id="heavyWoundModal" class="modal">
    <h3>Heavy Wound Inflicted</h3>
    <p id="heavyWoundMessage"></p>
    <button onclick="onModalClose('heavyWoundModal')">Close</button>
</div>
<div id="shopModal" class="modal">
    <h3>Shop</h3>
    <div id="shopContent"></div>
    <button onclick="onModalClose('shopModal')">Close</button>
</div>
<!-- Game Sections -->
<div id="gameLogo" class="game-section">
    <img src="BSBTitles6.webp" class="logo-img" alt="Cursed Sword Legacy">
</div>

<div id="swordSection" class="game-section">
    <div id="swordStats">
        <h2>Sword Upgrades</h2>
        <div class="stat tooltip">
            Energy: <span id="energy">0</span>/<span id="maxEnergy">100</span>
            <span class="tooltiptext">Current/Maximum energy stored in the sword</span>
        </div>
        <div class="stat tooltip">
            Total Kills: <span id="totalKills">0</span>
            <span class="tooltiptext">Total number of enemies defeated</span>
        </div>
    </div>
    <div id="upgrades"></div>
</div>

<div id="zonesSection" class="game-section">
    <div id="tabs">
        <button class="active" onclick="showTab('zones')">Zones</button>
        <button onclick="showTab('achievements')">Achievements</button>
    </div>
    <div id="tab-content">
        <div id="zones-content">
            <h2>Zones</h2>
            <div id="enemies"></div> <!-- Existing zones content -->
        </div>
        <div id="achievements-content" style="display: none;">
            <h2>Achievements</h2>
            <div id="achievements-list"></div>
        </div>
    </div>
</div>

<div id="wielderSection" class="game-section">

    <div id="statsDiv"></div>
    <div id="equipmentDiv"></div>
</div>

<div id="actionsSection" class="game-section">
    <h2>üéÆ Actions</h2>
    <div class="action-buttons">
        <span class="tooltip">
            <button id="restButton" onclick="onActionButtonClick('resting')">Rest</button>
            <span class="tooltiptext">Recover health faster (disables other actions)</span>
        </span>
        <span class="tooltip">
            <button id="trainButton" onclick="onActionButtonClick('training')">Train</button>
            <span class="tooltiptext">Gain 2 EXP/second (disables other actions)</span>
        </span>
        <span class="tooltip">
            <button id="healButton" onclick="healWielder()">Heal wielder (10 energy)</button>
            <span class="tooltiptext">Restore 25% health for 10 energy</span>
        </span><br>
        <span class="tooltip">
            <button id="changeWielderButton" onclick="showRaceSelection()">Change Wielder </button>
            <span class="tooltiptext">Lose your current wielder permanently. Pick the race of a new one.</span>
        </span>
    </div>
</div>

<div id="combatLog" class="game-section combat-window">
    <h2>Event Log</h2>
    <div id="combat-log" class="combat-log"></div>
</div>

<!-- Footer -->
<footer>
        <span class="tooltip">
            <a href="#" onclick="showStory()">üìñ</a>
            <span class="tooltiptext">View Sword's Story</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="showStatistics()">üìä</a>
            <span class="tooltiptext">Game Statistics</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="showChangelog()">üìú</a>
            <span class="tooltiptext">View Changelog</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="wipeSave()">‚ùå</a>
            <span class="tooltiptext">Delete Save File</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="showOptions()">‚öôÔ∏è</a>
            <span class="tooltiptext">Game Options</span>
        </span>
    <span class="tooltip">
            <a href="https://caffeineforge.com" target="_blank">üêô</a>
            <span class="tooltiptext">Visit Writer's Site</span>
    </span>
    <span class="tooltip">
            <a href="https://www.royalroad.com/fiction/106967/bloodstained-blade-gamelit-sword-mc" target="_blank">üê¶</a>
            <span class="tooltiptext">Read the Story</span>
        </span>
</footer>

<script>
    // Initialize variables
   const game = {
       strory1Viewed: false,
       sellMode:false,
       isFighting: false,
       autoBattle: false,
       currentEnemy: null,
       controlBonus: 0,
       sword: {
           energy: 0,
           maxEnergy: 100,
           kills: 0,
           upgrades: {
               capacity: {
                   level: 1,
                   cost: 50
               },
               siphon: {
                   level: 1,
                   cost: 100
               },
               senses: {
                   level: 1,
                   cost: 200
               },
               connection: {
                   level: 1,
                   cost: 150
               },
               control: {
                   level: 1,
                   cost: 300
               },
               soul: {
                   level: 1,
                   cost: 500
               }
           }
       },
       wielder: null,
       statistics: {
           totalKills: 0,
           wieldersUsed: 0,
           mobKills: {},
           zoneKills: {}
       },
       story: [],
       unlockedUpgrades: [],
       unlockedRaces: ['human']
   };
   game.achievements = {
       noviceSlayer: {
           name: "Novice Slayer",
           description: "Defeat 100 enemies",
           condition: () => game.statistics.totalKills >= 100,
           bonus: {
               damageMultiplier: 1.05
           },
           unlocked: false,
           icon: "üó°Ô∏è" // Sword icon
       },
       energyHoarder: {
           name: "Energy Hoarder",
           description: "Accumulate 1000 energy",
           condition: () => game.sword.energy >= 1000,
           bonus: {
               maxEnergyMultiplier: 1.10
           },
           unlocked: false,
           icon: "üîã" // Battery icon
       },
       upgradeMaster: {
           name: "Upgrade Master",
           description: "Upgrade any sword upgrade to level 5",
           condition: () => Object.values(game.sword.upgrades).some(upg => upg.level >= 5),
           bonus: {
               upgradeCostReduction: 0.05
           },
           unlocked: false,
           icon: "üîß" // Wrench icon
       },
       zoneExplorer: {
           name: "Zone Explorer",
           description: "Explore all available zones",
           condition: () => gameData.zones.every(zone => zone.unlocked),
           bonus: {
               expMultiplier: 1.10
           },
           unlocked: false,
           icon: "üó∫Ô∏è" // Map icon
       },
       wielderVeteran: {
           name: "Wielder Veteran",
           description: "Have 5 different wielders",
           condition: () => game.statistics.wieldersUsed >= 5,
           bonus: {
               startingStats: 1
           },
           unlocked: false,
           icon: "üë•" // People icon
       }
   };
   let lastUsedZoneIndex = 0;

   let gameData, races, zones, upgradeCaps;
   game.currentAction = null;

   function showTab(tabName) {
       const zonesContent = document.getElementById('zones-content');
       const achievementsContent = document.getElementById('achievements-content');
       const zonesButton = document.querySelector('#tabs button:nth-child(1)');
       const achievementsButton = document.querySelector('#tabs button:nth-child(2)');

       if (tabName === 'zones') {
           zonesContent.style.display = 'block';
           achievementsContent.style.display = 'none';
           zonesButton.classList.add('active');
           achievementsButton.classList.remove('active');
       } else {
           zonesContent.style.display = 'none';
           achievementsContent.style.display = 'block';
           achievementsButton.classList.add('active');
           zonesButton.classList.remove('active');
           updateAchievementsTab(); // Update achievements when switching to that tab
       }
   }

   function checkAchievements() {
       Object.entries(game.achievements).forEach(([key, achievement]) => {
           if (!achievement.unlocked && achievement.condition()) {
               achievement.unlocked = true;
               addCombatMessage(
                   `Achievement Unlocked: ${achievement.name}! Bonus: ${getBonusDescription(achievement.bonus)}`,
                   'achievement'
               );
               if (achievement.bonus.maxEnergyMultiplier) {
                   calculateMaxEnergy(); // Update max energy if affected
               }
           }
       });
   }

   function checkAchievements() {
       Object.entries(game.achievements).forEach(([key, achievement]) => {
           if (!achievement.unlocked && achievement.condition()) {
               achievement.unlocked = true;
               addCombatMessage(
                   `Achievement Unlocked: ${achievement.name}! Bonus: ${getBonusDescription(achievement.bonus)}`,
                   'achievement'
               );
               if (achievement.bonus.maxEnergyMultiplier) {
                   calculateMaxEnergy(); // Update max energy if affected
               }
           }
       });
   }

   function getExpMultiplier() {
       let multiplier = 1;
       Object.values(game.achievements).forEach(ach => {
           if (ach.unlocked && ach.bonus.expMultiplier) {
               multiplier *= ach.bonus.expMultiplier;
           }
       });
       return multiplier;
   }

   function updateAchievementsTab() {
       const list = document.getElementById('achievements-list');
       list.innerHTML = Object.entries(game.achievements).map(([key, ach]) => `
        <div class="achievement-icon tooltip ${ach.unlocked ? 'unlocked' : ''}">
            <span>${ach.icon}</span>
            <span class="tooltiptext">
                ${ach.name}<br>
                ${ach.description}<br>
                Status: ${ach.unlocked ? 'Unlocked' : 'Locked'}<br>
                ${ach.unlocked ? `Bonus: ${getBonusDescription(ach.bonus)}` : ''}
            </span>
        </div>
    `).join('');
   }

   function getBonusDescription(bonus) {
       if (bonus.damageMultiplier) return `+${(bonus.damageMultiplier - 1) * 100}% damage`;
       if (bonus.maxEnergyMultiplier) return `+${(bonus.maxEnergyMultiplier - 1) * 100}% max energy`;
       if (bonus.upgradeCostReduction) return `-${bonus.upgradeCostReduction * 100}% upgrade cost`;
       if (bonus.expMultiplier) return `+${(bonus.expMultiplier - 1) * 100}% EXP gain`;
       if (bonus.startingStats) return `+${bonus.startingStats} to all starting stats`;
       return '';
   }
   // Wielder Generation
   function generateWielder(race, isInitial = false) {
       game.statistics.wieldersUsed = (game.statistics.wieldersUsed ?? 0) + 1;
       checkAchievements();
       if (!race) {
           const availableRaces = Object.keys(races).filter(r => races[r].unlocked);
           race = availableRaces[Math.floor(Math.random() * availableRaces.length)];
       }
       const raceData = races[race];
       const startingBonus = game.achievements.wielderVeteran.unlocked ? game.achievements.wielderVeteran.bonus.startingStats : 0;
       if (isInitial && race === 'goblin') {
        baseStats = {
            strength: 5,
            swordfighting: 5,
            endurance: 2,
            willpower: Math.floor(Math.random() * 50 + 50) + (raceData.stats.willpower || 0) + startingBonus
        };
    } else {
        baseStats = {
            strength: Math.floor(Math.random() * 6 + 1) + (raceData.stats.strength || 0) + startingBonus,
            swordfighting: Math.floor(Math.random() * 6 + 1) + (raceData.stats.swordfighting || 0) + startingBonus,
            endurance: Math.floor(Math.random() * 2 + 1) + (raceData.stats.endurance || 0) + startingBonus,
            willpower: Math.floor(Math.random() * 50 + 50) + (raceData.stats.willpower || 0) + startingBonus
        };
    }
       return {
           name: raceData.names[Math.floor(Math.random() * raceData.names.length)],
           race,
           baseStats: {
               ...baseStats
           },
           currentStats: {
               ...baseStats
           },
           wounds: [],
           level: 1,
           statPoints: 0,
           exp: 0,
           currentLife: baseStats.endurance * 5,
           equipment: {
               helmet: null,
               body: null,
               gauntlets: null,
               weapon: null,
               shield: null,
               boots: null,
               ring: null,
               amulet: null
           },
           inventory: [],
           gold: 0,
           resting: false,
           training: false,
           defeated: false,
       };
   }

   // Action Handling
   function onActionButtonClick(actionType) {
       const buttons = ['restButton', 'trainButton'];
       buttons.forEach(id => document.getElementById(id).classList.remove('active-action'));

       switch (actionType) {
           case 'resting':
               game.currentAction = game.currentAction === 'resting' ? null : 'resting';
               if (game.currentAction) document.getElementById('restButton').classList.add('active-action');
               break;
           case 'training':
               game.currentAction = game.currentAction === 'training' ? null : 'training';
               if (game.currentAction) document.getElementById('trainButton').classList.add('active-action');
               break;

       }
       updateDisplay();
   }

   function startAutoBattle() {
       if (!isAnyModalOpen()) {
           if (!gameData.zones[lastUsedZoneIndex]) lastUsedZoneIndex = 0;
           const zone = gameData.zones[lastUsedZoneIndex];
           const enemyIndex = Math.floor(Math.random() * zone.enemies.length);
           attackEnemy(lastUsedZoneIndex, enemyIndex);
       }
   }

   function healWielder() {
       if (game.sword.energy >= 10 && game.wielder.currentLife < game.wielder.currentStats.endurance * 5) {
           game.sword.energy -= 10;
           game.wielder.currentLife = Math.min(
               game.wielder.currentLife + Math.floor(game.wielder.currentStats.endurance * 1.25),
               game.wielder.currentStats.endurance * 5
           );
           updateDisplay();
       }
   }

   // Display Updates
   function getWoundText(stat) {
       const count = game.wielder.wounds.filter(w => w === stat).length;
       return count > 0 ? `\n(Wounded: -${count})` : '';
   }

   function updateCombatStats() {
       const wielder = game.wielder;

       // Update HP
       const hpElement = document.querySelector('#wielderStats .stat:nth-child(5)'); // Assuming HP is 5th stat
       if (hpElement) {
           hpElement.innerHTML = `
            HP: ${Math.max(wielder.currentLife, 0)}/${wielder.currentStats.endurance*5}
            <span class="tooltiptext">Current/Maximum health (Regenerates 1 HP every 5s)</span>
        `;
       }

       // Update EXP
       const expElement = document.querySelector('#wielderStats .stat:nth-child(7)'); // Assuming EXP is 7th stat
       if (expElement) {
           expElement.innerHTML = `
            EXP: ${Math.round(wielder.exp)}/${wielder.level * 100}
            <span class="tooltiptext">Gain a level every 100 exp points</span>
        `;
       }

       // Update Energy
       document.getElementById('energy').textContent = `${game.sword.energy.toFixed(1)} / ${game.sword.maxEnergy.toFixed(1)}`;

       // Update Total Kills
       document.getElementById('totalKills').textContent = game.statistics.totalKills;
   }

   function updateDisplay() {
        const wielder = game.wielder;
    const effectiveStats = getEffectiveStats();
    const baseDamage = effectiveStats.strength * 2 + effectiveStats.swordfighting;
    const controlDamageBonus = baseDamage * game.controlBonus;
    const lifesteal = game.sword.upgrades.siphon.level;
    const totalDamage = (baseDamage + lifesteal + controlDamageBonus) * getDamageMultiplier();

    // Sword Stats
    document.getElementById('energy').textContent = game.sword.energy.toFixed(0);
    document.getElementById('maxEnergy').textContent = game.sword.maxEnergy.toFixed(0);
    document.getElementById('totalKills').textContent = game.statistics.totalKills;


    // Wielder Stats
    let wielderHTML = `
        <div class="stat">Name: <span id="wielderName">${wielder.name}</span></div>
        <div class="stat">Race: <span id="wielderRace">${wielder.race}</span></div>
        <div class="stat tooltip">
            Strength: ${effectiveStats.strength}${wielder.baseStats.strength > effectiveStats.strength ? '‚ö†' : ''}
            <span class="tooltiptext">Increases damage dealt per strike (+2 Damage)${getWoundText('strength')}</span>
        </div><br />
        <div class="stat tooltip">
            Swordfighting: ${effectiveStats.swordfighting}${wielder.baseStats.swordfighting > effectiveStats.swordfighting ? '‚ö†' : ''}
            <span class="tooltiptext">Reduces incoming damage (+1 resistance) Increases damage (+1)${getWoundText('swordfighting')}</span>
        </div><br />
        <div class="stat tooltip">
            Endurance: ${effectiveStats.endurance}
            <span class="tooltiptext">Determines maximum health (HP = Endurance √ó 5)</span>
        </div><br />
        <div class="stat tooltip">
            HP: ${Math.max(wielder.currentLife.toFixed(1), 0)}/${effectiveStats.endurance * 5}
            <span class="tooltiptext">Current/Maximum health (Regenerates 1 HP every 5s)</span>
        </div><br />
        <div class="stat tooltip">
            Willpower: ${effectiveStats.willpower}${wielder.baseStats.willpower > effectiveStats.willpower ? '‚ö†' : ''}
            <span class="tooltiptext">Increases exp gain, reduces control (up to 100% at 200)${getWoundText('willpower')}</span>
        </div><br />
        <div class="stat tooltip">
            EXP: ${Math.round(wielder.exp.toFixed(1))}/${wielder.level * 100}
            <span class="tooltiptext">Gain a level every 100 exp points</span>
        </div><br />
        <div class="stat tooltip">
            Level: ${wielder.level}
        </div><br />
        <div class="stat tooltip">
            Predicted Damage: ${totalDamage.toFixed(1)}
            <span class="tooltiptext">
                Base: ${baseDamage} (Strength: ${effectiveStats.strength} √ó 2 + Swordfighting: ${effectiveStats.swordfighting})<br>
                Control Bonus: +${(baseDamage * game.controlBonus).toFixed(1)} (${(game.controlBonus * 100).toFixed(0)}%)<br>
                Lifesteal: +${game.sword.upgrades.siphon.level} damage & HP per hit
            </span>
        </div><br />
        <div class="stat tooltip">
            Damage Reduction: ${effectiveStats.swordfighting}
            <span class="tooltiptext">Reduces incoming damage by this amount</span>
        </div>
        <br />
        <br />
        <div class="stat tooltip">
            Gold: ${game.wielder.gold}
            <span class="tooltiptext">The amount of gold you have, spend it in shops!</span>
        </div>


    `;

        // Equipment
    let equipmentHTML = '';
    if (gameData.zones[3].unlocked) {
        equipmentHTML += '<h3>Equipment</h3>';
        equipmentHTML += '<div id="equipment-grid">';
        const slots = ['helmet', 'body', 'gauntlets', 'weapon', 'shield', 'boots', 'ring', 'amulet'];
        slots.forEach(slot => {
            const item = game.wielder.equipment[slot];
            equipmentHTML += `
                <div class="equipment-slot tooltip ${getItemBorderClass(item)}" onclick="unequipItem('${slot}')">
                    <img src="${item ? item.icon : 'placeholder.png'}" alt="${item ? item.name : 'none'}">
                    <span class="tooltiptext">${item ? getItemTooltip(item) : ''}</span>
                </div>`;
        });
        equipmentHTML += '</div>';

        equipmentHTML += '<h3>Inventory</h3>';
        equipmentHTML += '<div id="inventory-grid">';
        game.wielder.inventory.forEach((item, index) => {
            equipmentHTML += `
                <div class="inventory-slot tooltip ${getItemBorderClass(item)}" onclick="handleInventoryClick(${index})">
                    <img src="${item.icon}" alt="${item.name}">
                    <span class="tooltiptext">${getItemTooltip(item)}</span>
                </div>`;
        });
        for (let i = game.wielder.inventory.length; i < 9; i++) {
            equipmentHTML += '<div class="inventory-slot"><img src="placeholder.png" alt="empty"></div>';
        }
        equipmentHTML += '</div>';

        equipmentHTML += `
            <button id="sellModeButton" onclick="toggleSellMode()">
                ${game.sellMode ? 'Exit Sell Mode' : 'Enter Sell Mode'}
            </button>`;
    }


    // Combine wielder and equipment HTML
    document.getElementById('statsDiv').innerHTML = wielderHTML ;
    document.getElementById('equipmentDiv').innerHTML = equipmentHTML;

    // Upgrades
    document.getElementById('upgrades').innerHTML = Object.entries(game.sword.upgrades)
        .map(([name, data]) => `
            <div class="upgrade tooltip">
                ${name.charAt(0).toUpperCase() + name.slice(1)} (Level ${data.level})
                <span class="tooltiptext">${getUpgradeTooltip(name)}</span>
                <button onclick="buyUpgrade('${name}')" ${data.level >= gameData.upgradeCaps[name] ? 'disabled' : game.sword.energy >= data.cost ? '' : 'disabled'}>
                    ${data.level >= gameData.upgradeCaps[name] ? 'Max level' : `Upgrade (${Math.round(data.cost)} energy)`}
                </button>
            </div>
        `)
        .join('');

    // Zones
    document.getElementById('enemies').innerHTML = gameData.zones
        .filter(zone => zone.unlocked)
        .map((zone, zi) => `
            <div class="zone">
                <h4>${zone.name}</h4>
                <span class="tooltip">
                    <button class="explore-btn" onclick="exploreZone(${zi})">Explore</button>
                    <span class="tooltiptext">
                        Possible enemies:<br>
                        ${zone.enemies.map(e => `${e.name} (Lv. ${e.level}, ${e.endurance*5} HP)`).join('<br>')}
                    </span>
                </span>
                ${zi > 3 ? `<button onclick="openShop(${zi})">Shop</button>` : ''}
                <span class="autofight">
                    <input type="checkbox" id="auto-${zi}" onchange="toggleAutoFight(${zi})"
                        ${game.currentAction === 'autoFighting' && lastUsedZoneIndex === zi ? 'checked' : ''};
                        ${game.sword.upgrades.connection.level < zi + 1 || (game.currentAction && game.currentAction !== 'autoFighting') ? 'disabled' : ''}>
                    <label for="auto-${zi}">Auto explore</label>
                </span>
            </div>
        `)
        .join('');
    // Actions
    const actionInProgress = !!game.currentAction;
    document.querySelectorAll('#enemies button').forEach(btn => {
        btn.disabled = actionInProgress || game.wielder.defeated;
    });
    gameData.zones.forEach((_, zi) => {
        const checkbox = document.getElementById(`auto-${zi}`);
        if (checkbox) {
            checkbox.disabled = game.sword.upgrades.connection.level < zi + 1 || game.wielder.defeated || (game.currentAction && game.currentAction !== 'autoFighting');
        }
    });

    // Button state management
    const healButton = document.getElementById('healButton');
    const changeWielderButton = document.getElementById('changeWielderButton');
    const restButton = document.getElementById('restButton');
    const trainButton = document.getElementById('trainButton');

    if (game.wielder.defeated) {
        restButton.disabled = true;
        trainButton.disabled = true;
        healButton.disabled = true;
        changeWielderButton.disabled = false;
    } else {
        restButton.disabled = false;
        trainButton.disabled = false;
        healButton.disabled = game.sword.energy < 10 || game.wielder.currentLife >= effectiveStats.endurance * 5;
        changeWielderButton.disabled = game.sword.energy < 10;
    }
   }

function openShop(zoneIndex) {
    document.getElementById('shopModal').style.display = 'block';
    const shopContent = `
        <h3>Shop - ${gameData.zones[zoneIndex].name}</h3>
        <p>Gold: ${game.wielder.gold}</p>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
        ${items.map(item => `
            <div class="shop-item tooltip ${getItemBorderClass(item)}">
                <img src="${item.icon}" alt="${item.name}">
                <span class="tooltiptext">${getItemTooltip(item)}<br>Price: ${item.price} gold</span>
                <button onclick="buyItem('${item.name}')">Buy</button>
            </div>
        `).join('')}
        </div>`;
    document.getElementById('shopContent').innerHTML = shopContent;
}
function getItemBorderClass(item) {
    if (!item) return '';
    const statSum = Object.values(item.stats).reduce((sum, val) => sum + val, 0);
    switch (statSum) {
        case 1: return 'border-white';
        case 2: return 'border-blue';
        case 3: return 'border-green';
        case 4: return 'border-orange';
        case 5: return 'border-purple';
        default: return '';
    }
}
   function buyItem(itemName) {
       const item = items.find(i => i.name === itemName);
       if (game.wielder.gold >= item.price && game.wielder.inventory.length < 9) {
           game.wielder.gold -= item.price;
           game.wielder.inventory.push(item);
           updateDisplay();
       } else {
           alert('Not enough gold or inventory full');
       }
   }
   // Explore Zone Logic
   function exploreZone(zoneIndex) {
       if (game.currentAction && game.currentAction !== 'autoFighting') return;
       lastUsedZoneIndex = zoneIndex;
       const enemyIndex = Math.floor(Math.random() * gameData.zones[zoneIndex].enemies.length);
       attackEnemy(zoneIndex, enemyIndex);
   }

   // Toggle Autofight
   function toggleAutoFight(zoneIndex) {
       const checkbox = document.getElementById(`auto-${zoneIndex}`);
       if (checkbox.checked) {
           gameData.zones.forEach((_, i) => {
               if (i !== zoneIndex && document.getElementById(`auto-${i}`) != null) document.getElementById(`auto-${i}`).checked = false;
           });
           game.currentAction = 'autoFighting';
           lastUsedZoneIndex = zoneIndex;

           startAutoBattle();
       } else {
           game.currentAction = null;

       }
       updateDisplay();
   }

   function getUpgradeTooltip(name) {
       const tooltips = {
           capacity: 'Increases maximum energy',
           siphon: 'Adds 1 lifesteal per level',
           senses: 'Unlocks stronger enemies',
           connection: 'Improves bond with the wielder, unlocks additional mechanics, increases passive health regen',
           control: 'Increases damage bonus (20% at 0 willpower, 0% at 200+ willpower per level)',
           soul: 'Discover more of your history'
       };
       return tooltips[name] || '';
   }

   // Combat Logic
   function calculateExpGain(baseExp) {
       const enemy = gameData.zones[game.currentEnemy.zoneIndex].enemies[game.currentEnemy.enemyIndex];
       const levelDiff = enemy.level - game.wielder.level;
       const expMultiplier = 1 + (levelDiff * 0.2);
       const expGained = Math.max(Math.floor(baseExp * expMultiplier), 0) * (1 + game.wielder.currentStats.willpower / 200);
       addCombatMessage(`Gained ${expGained.toFixed(1)} exp. ${(expMultiplier * 100).toFixed(2)}% of base due to level gap.`, 'player-stat');
       return expGained;
   }

   function getMaxEnergyMultiplier() {
       let multiplier = 1;
       Object.values(game.achievements).forEach(ach => {
           if (ach.unlocked && ach.bonus.maxEnergyMultiplier) {
               multiplier *= ach.bonus.maxEnergyMultiplier;
           }
       });
       return multiplier;
   }

   function calculateMaxEnergy() {
       let base = 100; // Base max energy
       base *= Math.pow(2, game.sword.upgrades.capacity.level - 1); // Apply capacity upgrade
       base *= getMaxEnergyMultiplier(); // Apply achievement bonuses
       game.sword.maxEnergy = base;
   }

   function getUpgradeCostReduction() {
       let reduction = 0;
       Object.values(game.achievements).forEach(ach => {
           if (ach.unlocked && ach.bonus.upgradeCostReduction) {
               reduction += ach.bonus.upgradeCostReduction;
           }
       });
       return reduction;
   }
   async function attackEnemy(zoneIndex, enemyIndex) {
       if (game.currentAction && game.currentAction !== 'autoFighting') return;
       const effectiveStats = getEffectiveStats();
       lastUsedZoneIndex = zoneIndex;
       const wielder = game.wielder;
       game.isFighting = true;
       game.currentEnemy = {
           zoneIndex,
           enemyIndex
       };
       const enemy = gameData.zones[zoneIndex].enemies[enemyIndex];
       let enemyLife = enemy.endurance * 5;

       if (wielder.currentLife <= 0) {
           addCombatMessage('Wielder is too injured to fight!', 'damage');
           game.isFighting = false;
           updateDisplay();
           return;
       }

       const controlLevel = game.sword.upgrades.control.level;
       const willpower = Math.min(wielder.currentStats.willpower, 200); // Cap at 200
       game.controlBonus = controlLevel * 0.2 * (1 - willpower / 200); // 20% at 0 willpower, 0% at 200+

       const baseDamage = effectiveStats.strength * 2 + effectiveStats.swordfighting;
       const controlDamageBonus = baseDamage * game.controlBonus;
       const lifesteal = game.sword.upgrades.siphon.level; // 1 lifesteal per level
       const damageMultiplier = getDamageMultiplier();
       const totalDamage = (baseDamage + lifesteal + controlDamageBonus) * damageMultiplier;
       addCombatMessage(`Engaging ${enemy.name} (${enemy.endurance*5} HP)`, 'player-stat');

       while (enemyLife > 0 && wielder.currentLife > 0 && !isAnyModalOpen()) {
           const damageDealt = Math.min(totalDamage, enemyLife);
           const lifestealHealing = Math.min(lifesteal, enemyLife); // Can't heal more than damage dealt
           enemyLife -= damageDealt;
           wielder.currentLife = Math.min(
               effectiveStats.endurance * 5,
               wielder.currentLife + lifestealHealing
           );

           addCombatMessage(
               `Dealt ${damageDealt.toFixed(1)} damage (Base: ${baseDamage}, Control: ${controlDamageBonus.toFixed(1)}) ` +
               `Lifesteal: +${lifestealHealing} HP | Enemy HP: ${enemyLife}`,
               'damage'
           );
           const enemyDamage = Math.max(enemy.strength * 2 -
               Math.floor(game.wielder.currentStats.swordfighting), 1);
           game.wielder.currentLife -= enemyDamage;

           addCombatMessage(`Took ${enemyDamage} damage ` +
               `(Base: ${enemy.strength*2}, Defense: ` +
               `${Math.floor(game.wielder.currentStats.swordfighting )})` +
               `Player Hp left: ${game.wielder.currentLife}`, 'damage');
           await new Promise(resolve => setTimeout(resolve, 500));
       }
       if (isAnyModalOpen()) {
           addCombatMessage('Combat paused due to open menu.', 'player-stat');
           game.isFighting = false; // Reset fighting state
           return;
       }
       if (wielder.currentLife <= 0) {
           addCombatMessage('Lost the fight! Disengaging. Rest or heal.', 'damage');

           if (game.currentAction === 'autoFighting') onActionButtonClick('autoFighting');
           applyHeavyWound();
           game.isFighting = false;
           updateDisplay();
           return;
       }
       if (enemyLife <= 0) {
           defeatEnemy(enemy, zoneIndex);
       }


       updateDisplay();
   }

   function defeatEnemy(enemy, zoneIndex) {
       wielder = game.wielder;
       const energyGain = enemy.endurance * 5 * (1 + game.sword.upgrades.siphon.level * 0.1);
       game.sword.energy = Math.min(game.sword.energy + energyGain, game.sword.maxEnergy);
       addCombatMessage(`${enemy.name} defeated! +${energyGain.toFixed(1)} energy`, 'enemy-defeated');

       const expGained = calculateExpGain(enemy.exp);
       game.wielder.exp += expGained;
       game.statistics.zoneKills[zoneIndex] = (game.statistics.zoneKills[zoneIndex] ?? 0) + 1;
       game.statistics.totalKills = (game.statistics.totalKills ?? 0) + 1;
       game.statistics.mobKills[enemy.name] = (game.statistics.mobKills[enemy.name] ?? 0) + 1;
       checkAchievements();
       while (wielder.exp >= wielder.level * 100) {
           wielder.exp -= wielder.level * 100;
           wielder.level++;
           wielder.statPoints += calculateStatPointsPerLevel();
           applyLevelBonuses(); // Apply race-specific bonuses
           showLevelUpModal();
       }
       if (zoneIndex >= 4) {
           const goldDrop = enemy.level * 10; // Adjustable formula
           game.wielder.gold += goldDrop;
           addCombatMessage(`Found ${goldDrop} gold`, 'player-stat');
       }
       game.isFighting = false;
       if (game.currentAction === 'autoFighting') startAutoBattle();


   }

   function getUpgradeCostReduction() {
       let reduction = 0;
       Object.values(game.achievements).forEach(ach => {
           if (ach.unlocked && ach.bonus.upgradeCostReduction) {
               reduction += ach.bonus.upgradeCostReduction;
           }
       });
       return reduction;
   }

   function getDamageMultiplier() {
       let multiplier = 1;
       Object.values(game.achievements).forEach(ach => {
           if (ach.unlocked && ach.bonus.damageMultiplier) {
               multiplier *= ach.bonus.damageMultiplier;
           }
       });
       return multiplier;
   }

   function updateUpgrades() {
       const upgradesDiv = document.getElementById('upgrades');
       const costReduction = getUpgradeCostReduction();
       upgradesDiv.innerHTML = Object.entries(game.sword.upgrades).map(([name, upg]) => {
           const effectiveCost = upg.cost * (1 - costReduction);
           return `<button onclick="buyUpgrade('${name}')">${name} (Level ${upg.level}) - Cost: ${effectiveCost.toFixed(1)}</button>`;
       }).join('');
   }

   function isAnyModalOpen() {
       const modals = [
           'raceSelectionModal',
           'unlocksModal',
           'statsModal',
           'optionsModal',
           'storyModal',
           'changelogModal',
           'levelUpModal',
           'wielderDeathModal',
           'heavyWoundModal'
       ];
       return modals.some(id => document.getElementById(id).style.display === 'block');
   }

   function calculateStatPointsPerLevel() {
       const race = game.wielder.race;
       const basePoints = gameData.races[race].skillpoints; // Default to 1 if not specified
       return basePoints;
   }
   // Level Up
   function showLevelUpModal() {
updateStatPointsInfo();
    const effectiveStats = getEffectiveStats();
    document.getElementById('currentStatsDisplay').innerHTML = `
        Strength: ${effectiveStats.strength.toFixed(1)} | Swordfighting: ${effectiveStats.swordfighting.toFixed(1)} |
        Endurance: ${effectiveStats.endurance.toFixed(1)} | HP: ${game.wielder.currentLife.toFixed(1)}/${(effectiveStats.endurance * 5).toFixed(1)} |
        Willpower: ${effectiveStats.willpower.toFixed(1)}
    `;
    document.getElementById('levelUpModal').style.display = 'block';
   }

   function applyLevelBonuses() {
       const race = game.wielder.race;
       const levelBonuses = gameData.races[race].levelBonuses || {};
       for (const [stat, bonus] of Object.entries(levelBonuses)) {
           game.wielder.currentStats[stat] += bonus;
           if (stat === 'enduranec') {
               game.wielder.currentLife += bonus; // Increase current HP when max HP increases
           }
       }
   }

function allocatePoint(stat) {
    game.wielder.currentStats[stat]++;
    game.wielder.statPoints--;
    if (stat === 'endurance') {
        game.wielder.currentLife += 5;
    }
    if (stat === 'willpower') game.wielder.currentStats.willpower += 4;
    if (game.wielder.statPoints <= 0) {
        document.getElementById('levelUpModal').style.display = 'none'; // Close modal immediately
    } else {
        showLevelUpModal(); // Refresh only if points remain
    }
    updateDisplay();
}

   function applyHeavyWound() {
       const stats = ['strength', 'swordfighting', 'willpower'];
       const affectedStat = stats[Math.floor(Math.random() * stats.length)];
       game.wielder.wounds.push(affectedStat);
       const woundCount = game.wielder.wounds.length;
       game.wielder.currentStats[affectedStat] = Math.max(
           game.wielder.baseStats[affectedStat] - game.wielder.wounds.filter(w => w === affectedStat).length,
           1
       );
       let message = `Heavy wound inflicted! Permanent -1 to ${affectedStat}. This is the ${woundCount}${['st', 'nd', 'rd'][woundCount - 1] || 'th'} wound.`;
       if (woundCount < 3) {
           message += ` If they receive a 3rd wound, they will die.`;
           addCombatMessage(message, 'damage');
           document.getElementById('heavyWoundMessage').textContent = message;
           document.getElementById('heavyWoundModal').style.display = 'block';
       } else {
           handleWielderDeath(affectedStat);
       }
       updateDisplay();
   }

   function handleWielderDeath(affectedStat) {
       game.wielder.defeated = true;
       game.currentAction = null; // Stop any ongoing actions
       game.sword.energy = 0;
       const message = affectedStat ?
           `Your wielder has succumbed to their wounds after receiving a heavy wound to ${affectedStat}.` :
           'Your wielder has died from their wounds.';
       addCombatMessage(message, 'damage');
       document.getElementById('wielderDeathMessage').textContent = message;
       document.getElementById('wielderDeathModal').style.display = 'block';
       updateDisplay();
   }
   // UI Functions
   function showRaceSelection() {
 const modal = document.getElementById('raceSelectionModal');
    gameData.zones = gameData.zones.map((zone, index) => ({
        ...zone,
        unlockRace: Object.keys(races).find(race => races[race].unlockRequirement?.zone === index)
    }));

    let content = '<div class="race-list">';
    Object.entries(races).forEach(([raceKey, raceData]) => {
        const zone = gameData.zones[raceData.unlockRequirement?.zone];
        const kills = raceData.unlockRequirement ? (game.statistics.zoneKills[raceData.unlockRequirement.zone] || 0) : 0;
        const required = raceData.unlockRequirement?.kills || 0;
        raceData.unlocked = raceData.unlocked || kills >= required;

        const baseRanges = {
            strength: isInitial ? 5 : Math.floor(Math.random() * 6 + 1),
            swordfighting: isInitial ? 5 : Math.floor(Math.random() * 6 + 1),
            endurance: isInitial ? 2 : Math.floor(Math.random() * 2 + 1),
            willpower: Math.floor(Math.random() * 50 + 50)
        };
        const stats = {
            strength: baseRanges.strength + (raceData.stats.strength || 0),
            swordfighting: baseRanges.swordfighting + (raceData.stats.swordfighting || 0),
            endurance: baseRanges.endurance + (raceData.stats.endurance || 0),
            willpower: baseRanges.willpower + (raceData.stats.willpower || 0)
        };

        const tooltipClass = raceData.unlocked ? 'tooltip' : '';
        content += `
            <div onclick="selectRace('${raceKey}')" class="race-option ${raceData.unlocked ? '' : 'locked'} ${tooltipClass}">
                <h4>${raceKey.toUpperCase()}</h4>
                <div class="stats">
                    Strength: ${stats.strength.toFixed(1)} | Swordfighting: ${stats.swordfighting.toFixed(1)} |
                    Endurance: ${stats.endurance.toFixed(1)} | Willpower: ${stats.willpower.toFixed(1)}
                </div>
                ${!raceData.unlocked ? `
                    <div class="unlock-requirement">
                        ${required} ${zone?.name} kills (${kills}/${required})
                    </div>
                ` : ''}
                ${raceData.unlocked ? `
                    <span class="tooltiptext">
                        Starting stats:<br>
                        Strength: ${stats.strength.toFixed(1)}<br>
                        Swordfighting: ${stats.swordfighting.toFixed(1)}<br>
                        Endurance: ${stats.endurance.toFixed(1)}<br>
                        Willpower: ${stats.willpower.toFixed(1)}
                    </span>
                ` : ''}
            </div>
        `;
    });
    content += '</div>';
    document.getElementById('raceOptions').innerHTML = content;
    modal.style.display = 'block';
    adjustTooltipPosition();
   }

   function onModalClose(modalId) {
       document.getElementById(modalId).style.display = 'none';
       if (game.currentAction === 'autoFighting' && !game.isFighting && !isAnyModalOpen()) {
           startAutoBattle();
       }
       updateDisplay();
   }

   function selectRace(race) {
       if (races[race].unlocked) {
           game.wielder = generateWielder(race);
           document.getElementById('raceSelectionModal').style.display = 'none';
           updateDisplay();
       }
   }

   function showStatistics() {
       document.getElementById('statisticsContent').innerHTML = `
                <p>Total Kills: ${game.statistics.totalKills}</p>
                <p>Wielders Used: ${game.statistics.wieldersUsed}</p>
                <h4>Kills by Enemy:</h4>
                ${Object.entries(game.statistics.mobKills).map(([mob, count]) => `<p>${mob}: ${count}</p>`).join('')}
            `;
       document.getElementById('statsModal').style.display = 'block';
   }

   function addCombatMessage(text, className) {
       const logElement = document.createElement('div');
       logElement.className = `log-entry ${className}`;
       logElement.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
       const combatLog = document.getElementById('combat-log');
       combatLog.appendChild(logElement);
       if (combatLog.children.length > 50) combatLog.removeChild(combatLog.firstChild);
       combatLog.scrollTop = combatLog.scrollHeight;
   }

   function updateStatPointsInfo() {

       const race = game.wielder.race;
       const basePoints = gameData.races[race].skillpoints || 1;

       const totalPoints = game.wielder.statPoints;
       const info = `You have ${totalPoints} stat points to allocate. ` +
           `(Each level grants ${basePoints} point.)`;
       document.getElementById('statPointsInfo').textContent = info;
   }

   // Upgrades and Story
   function buyUpgrade(upgradeName) {
       const cap = gameData.upgradeCaps[upgradeName];
       const upgrade = game.sword.upgrades[upgradeName];
       const costReduction = getUpgradeCostReduction();
       const effectiveCost = upgrade.cost * (1 - costReduction);
       if (upgrade.level >= cap) {
           addCombatMessage(`Maximum ${upgradeName} level reached!`, 'damage');
           return;
       }
       if (game.sword.energy >= effectiveCost) {
           game.sword.energy -= effectiveCost;
           upgrade.level++;
           upgrade.cost *= 2;
           if (upgradeName === 'capacity') calculateMaxEnergy();
           if (upgradeName === 'senses') gameData.zones[upgrade.level - 1].unlocked = true;
           if (upgradeName === 'soul') {
               unlockNextStory();
               showStory();
           }
           updateDisplay();
           checkAchievements();
       }
   }

   function unlockNextStory() {
       const stories = gameData.story;
       const nextLockedStory = Object.entries(stories).find(([_, story]) => !story.unlocked);
       if (nextLockedStory) {
           const [storyKey] = nextLockedStory;
           stories[storyKey].unlocked = true;
           return true;
       }
       return false;
   }

   function showStory(vieved) {
       if (vieved) {
           if (!game.story1Vieved) showStory();
           game.story1Vieved = true;
           return;
       }
       const stories = Object.values(gameData.story).filter(story => story.unlocked);
       document.getElementById('storyContent').innerHTML = stories.length > 0 ?
           stories.map(story => `<div class="story-entry"><h4>${story.title}</h4><p>${story.entry.join('</p><p>')}</p></div>`).join('') :
           '<p>No story fragments unlocked yet</p>';
       document.getElementById('storyModal').style.display = 'block';
   }

   // Save System
   function saveGame() {
       console.log('Saved game');
       const saveData = {
           game,
           wielder: game.wielder,
           timestamp: Date.now(),
           gameData
       };
       localStorage.setItem('cursedSwordSave', JSON.stringify(saveData));
   }

   function loadGame() {
       console.log('Loading game');
       const saved = localStorage.getItem('cursedSwordSave');
       if (saved) {
           const saveData = JSON.parse(saved);
           const {
               achievements,
               ...gameDataToAssign
           } = saveData.game;
           Object.assign(game, gameDataToAssign);
           game.wielder = saveData.wielder;
           gameData = saveData.gameData;
       } else {
           game.wielder = generateWielder('goblin', true);
       }
   }



   // Footer Functions
   function showChangelog() {
       document.getElementById('changelogContent').innerHTML = `
                <p>v1.2 - Added Save System & Wounds</p>
                <p>v1.1 - Zone Combat System</p>
                <p>v1.0 - Base Game</p>
            `;
       document.getElementById('changelogModal').style.display = 'block';
   }

   function wipeSave() {
       if (confirm('Permanently delete all progress?')) {
           localStorage.removeItem('cursedSwordSave');
            game.wielder = generateWielder('goblin', true); // Predefined goblin on reset
            updateDisplay();
       }
   }

   function showOptions() {
       document.getElementById('optionsModal').style.display = 'block';
       document.getElementById('saveData').value = '';
   }

   function exportSave() {
       const saveData = {
           game,
           timestamp: Date.now(),
           version: 1.2
       };
       document.getElementById('saveData').value = JSON.stringify(saveData, null, 2);
   }

   function importSave() {
       try {
           const importData = JSON.parse(document.getElementById('saveData').value);
           if (importData.version !== 1.2) throw new Error('Invalid version');
           Object.keys(game).forEach(key => {
               if (importData.game[key]) game[key] = importData.game[key];
           });
           updateDisplay();
           alert('Save imported successfully!');
       } catch (e) {
           alert(`Import failed: ${e.message}`);
       }
   }

   // Game Initialization
   async function initGame() {
       gameData = await fetch('gameData.json').then(r => r.json());
       races = gameData.races;
       zones = gameData.zones;
       upgradeCaps = gameData.upgradeCaps;
       loadGame();
       saveGame();
       calculateMaxEnergy();
       updateDisplay();

       setInterval(() => {
           if (game.wielder.currentLife < game.wielder.currentStats.endurance * 5) {
               const regenRate = game.currentAction === 'resting' ? 5 : 1;
               game.wielder.currentLife = Math.min(
                   game.wielder.currentLife + regenRate,
                   getEffectiveStats().endurance * 5
               );
           }
           if (game.currentAction === 'training') {
               game.wielder.exp += 5;
               if (game.wielder.exp >= 100 * game.wielder.level) {
                   game.wielder.exp -= 100 * game.wielder.level;
                   game.wielder.level++;
                   game.wielder.statPoints += calculateStatPointsPerLevel();
                   applyLevelBonuses(); // Apply race-specific bonuses
                   showLevelUpModal();
               }
           }
           updateDisplay();
           saveGame();
       }, 5000);
       showStory(true);

   }

   function adjustTooltipPosition() {
       document.querySelectorAll('.tooltip').forEach(tooltip => {
           const tooltipText = tooltip.querySelector('.tooltiptext');
           if (!tooltipText) return;

           // Reset any inline styles from previous adjustments
           tooltipText.style.top = '';
           tooltipText.style.bottom = '';
           tooltipText.style.left = '50%';
           tooltipText.style.transform = 'translateX(-50%)';

           // Get bounding rectangles
           const tooltipRect = tooltipText.getBoundingClientRect();
           const triggerRect = tooltip.getBoundingClientRect();
           const viewportHeight = window.innerHeight;

           // Check if tooltip would be cut off above
           if (triggerRect.top - tooltipRect.height < 0) {
               // Position below instead
               tooltipText.style.top = 'calc(100% + 5px)';
               tooltipText.style.bottom = 'auto';
           } else if (triggerRect.bottom + tooltipRect.height > viewportHeight) {
               // Ensure it doesn't go below viewport bottom
               tooltipText.style.bottom = 'calc(100% + 5px)';
               tooltipText.style.top = 'auto';
           }

           // Adjust horizontal overflow
           if (tooltipRect.left < 0) {
               tooltipText.style.left = '0';
               tooltipText.style.transform = 'translateX(0)';
           } else if (tooltipRect.right > window.innerWidth) {
               tooltipText.style.left = 'auto';
               tooltipText.style.right = '0';
               tooltipText.style.transform = 'translateX(0)';
           }
       });
   }



   // Hook into updateDisplay to adjust tooltips after UI changes
   const originalUpdateDisplay = updateDisplay;
   updateDisplay = function() {
       originalUpdateDisplay();
       adjustTooltipPosition();
   };
   function handleInventoryClick(index) {
    if (game.sellMode) {
        const item = game.wielder.inventory[index];
        if (item) {
            const sellPrice = Math.floor(item.price / 2);
            game.wielder.gold += sellPrice;
            game.wielder.inventory.splice(index, 1);
            addCombatMessage(`Sold ${item.name} for ${sellPrice} gold`, 'player-stat');
            updateDisplay();
        }
    } else {
        const item = game.wielder.inventory[index];
        if (item) {
            const slot = item.type;
            if (game.wielder.equipment[slot]) {
                if (game.wielder.inventory.length < 9) {
                    const equippedItem = game.wielder.equipment[slot];
                    game.wielder.equipment[slot] = item;
                    game.wielder.inventory[index] = equippedItem;
                } else {
                    alert('Inventory full, cannot swap');
                }
            } else {
                game.wielder.equipment[slot] = item;
                game.wielder.inventory.splice(index, 1);
            }
            updateDisplay();
        }
    }
}

function unequipItem(slot) {
    if (game.wielder.equipment[slot] && game.wielder.inventory.length < 9) {
        game.wielder.inventory.push(game.wielder.equipment[slot]);
        game.wielder.equipment[slot] = null;
        updateDisplay();
    }
}

function toggleSellMode() {
    game.sellMode = !game.sellMode;
    updateDisplay();
}
function getEquipmentBonuses() {
    const bonuses = {};
    for (let slot in game.wielder.equipment) {
        if (game.wielder.equipment[slot]) {
            for (let stat in game.wielder.equipment[slot].stats) {
                bonuses[stat] = (bonuses[stat] || 0) + game.wielder.equipment[slot].stats[stat];
            }
        }
    }
    return bonuses;
}

function getEffectiveStats() {
    const effective = { ...game.wielder.currentStats };
    const bonuses = getEquipmentBonuses();
    for (let stat in bonuses) {
        effective[stat] = (effective[stat] || 0) + bonuses[stat];
    }
    return effective;
}

function getItemStatsText(item) {
    return Object.entries(item.stats).map(([stat, value]) => `+${value} ${stat}`).join(', ');
}

function getItemTooltip(item) {
    return `${item.name}<br>${getItemStatsText(item)}`;
}
const items = [
    { type: 'helmet', name: 'Iron Helmet', stats: { endurance: 1 }, price: 50, icon: 'helmet.png' },
    { type: 'weapon', name: 'Steel Sword', stats: { strength: 2 }, price: 100, icon: 'sword.png' },
    { type: 'body', name: 'Leather Armor', stats: { endurance: 2 }, price: 80, icon: 'armor.png' },
    { type: 'gauntlets', name: 'Gauntlets of Power', stats: { strength: 1 }, price: 60, icon: 'gauntlets.png' },
    { type: 'shield', name: 'Shield of Defense', stats: { swordfighting: 1 }, price: 70, icon: 'shield.png' },
    { type: 'boots', name: 'Boots of Speed', stats: { endurance: 1 }, price: 50, icon: 'boots.png' },
    { type: 'ring', name: 'Ring of Will', stats: { willpower: 5 }, price: 100, icon: 'ring.png' },
    { type: 'amulet', name: 'Amulet of Health', stats: { endurance: 3 }, price: 120, icon: 'amulet.png' }
];
   window.onload = initGame;
    </script>
</body>
</html>
