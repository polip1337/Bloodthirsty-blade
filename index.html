<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cursed Sword Idle</title>
    <style>
       :root {
    --logo-row-height: auto;
    --combat-row-height: 25%;
}

/* Grid Layout */
body {
    display: grid;
    grid-template:
        "logo    wielder  zones"    var(--logo-row-height)
        "sword   wielder  zones"    0.8fr
        "sword   actions  zones"    0.7fr
        "combat  combat   combat"   var(--combat-row-height)
        / 33%    33%      auto;
    height: 100vh;
    margin: 0;
    padding: 20px;
    gap: 15px;
    background-color: #1a1a1a;
    color: #ffffff;
    font-family: Arial, sans-serif;
}

/* General Styling */
.game-section {
    background-color: #2d2d2d;
    padding: 15px;
    border-radius: 8px;
    overflow: auto;
}

.game-section, .modal {
    overflow: visible; /* Prevent clipping of tooltips */
}

button {
    background-color: #4a0000;
    color: white;
    border: none;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 4px;
    cursor: pointer;
}

button:disabled {
    background-color: #666;
    cursor: not-allowed;
}

/* Grid Sections */
#gameLogo {
    grid-area: logo;
    text-align: center;
}

#swordSection {
    grid-area: sword;
}

#wielderSection {
    grid-area: wielder;
}

#zonesSection {
    grid-area: zones;
}

#actionsSection {
    grid-area: actions;
}

#combatLog {
    grid-area: combat;
}

/* Specific Components */
.logo-img {
    height: 80px;
    margin-bottom: 10px;
}

.stat {
    margin: 5px 0;
}

.upgrade {
    display: flex !important;
    justify-content: space-between;
    align-items: center;
    width: 330px;
    background-color: #3d3d3d;
    padding: 6px;
    margin: 5px 0;
    border-radius: 4px;
}

.upgrade button {
    order: 2;
    min-width: 120px;
}

.zone {
    background-color: #3d3d3d;
    padding: 10px;
    margin: 10px 0;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.zone h4 {
    margin: 0 0 10px 0;
    color: #ff6666;
}

.zone button:hover {
    background-color: #5a0000;
}

.combat-log {
    font-family: "Courier New", monospace;
    font-size: 0.9em;
    display: flex;
    flex-direction: column-reverse;
}

.log-entry {
    margin: 3px 0;
    padding: 2px 5px;
    border-radius: 3px;
}

.damage {
    background-color: #4a000055;
    color: #ff6666;
}

.player-stat {
    background-color: #004a0055;
    color: #66ff66;
}

.enemy-defeated {
    background-color: #4a4a0055;
    color: #ffff66;
}

/* Modals */
.modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #3d3d3d;
    padding: 20px;
    border-radius: 8px;
    z-index: 1000;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}

.stat-choice {
    margin: 10px;
    padding: 10px;
    background: #4a0000;
    cursor: pointer;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.stat-choice:hover {
    background: #5a0000;
}

/* Tooltips */
.tooltip {
    position: relative;
    display: inline-block;
    cursor: help;
}

.tooltip .tooltiptext {
    visibility: hidden;
    width: max-content;
    max-width: 300px;
    background-color: #2d2d2d;
    color: #fff;
    text-align: left;
    border-radius: 4px;
    padding: 8px 12px;
    position: absolute;
    z-index: 1002;
    border: 1px solid #ff6666;
    box-shadow: 0 0 5px rgba(255, 102, 102, 0.3);
    opacity: 0;
    transition: opacity 0.3s;
    white-space: normal;
    pointer-events: none;
    bottom: calc(100% + 5px);
    left: 50%;
    transform: translateX(-50%);
}

.tooltip:hover .tooltiptext {
    visibility: visible;
    opacity: 1;
}

footer .tooltip .tooltiptext {
    top: auto;
    bottom: calc(100% + 5px);
    transform: translateX(-50%);
}

/* Footer */
footer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 10px;
    background: #2d2d2d;
    text-align: center;
}

footer a {
    color: white;
    font-size: 24px;
    margin: 0 15px;
    text-decoration: none;
}

/* Race Selection */
.race-list {
    display: grid;
    gap: 15px;
}

.race-option {
    border: 1px solid #444;
    padding: 8px;
    margin: 5px 0;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.locked {
    opacity: 0.6;
    filter: grayscale(0.8);
}

.unlock-requirement {
    font-size: 0.9em;
    color: #ff6666;
    margin-top: 8px;
}

.stats {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin: 5px 0;
}

.race-option .stat {
    background: #3d3d3d;
    padding: 3px 8px;
    border-radius: 4px;
    border: 1px solid #4a0000;
}

/* Action Buttons */
.active-action {
    border: 2px solid #00ff00;
    box-shadow: 0 0 10px #00ff00;
}

/* Story Modal */
.story-entry {
    border-left: 3px solid #4a0000;
    padding-left: 10px;
    margin: 10px 0;
}

.race-option .stats {
    flex-grow: 1;
    margin-left: 10px;
}

.autofight {
    display: inline-block;
    margin-left: 10px;
}

.autofight input[type="checkbox"] {
    display: none;
}

.autofight label {
    cursor: pointer;
    padding: 5px 10px;
    background-color: #4a0000;
    border-radius: 4px;
    color: white;
}

.autofight input[type="checkbox"]:checked + label {
    background-color: #00ff00;
    color: #000;
}
#tabs {
    display: flex;
    gap: 5px;
}

#tabs button {
    background-color: #3d3d3d; /* Slightly lighter than content background */
    border: 1px solid #444;
    border-bottom: none;
    border-radius: 5px 5px 0 0; /* Rounded top corners */
    padding: 10px 20px;
    cursor: pointer;
    position: relative;
}

#tabs button.active {
    background-color: #2d2d2d; /* Matches game-section background */
    border-bottom: 1px solid #2d2d2d; /* Blends with content */
    bottom: -1px; /* Overlaps the tab-content border */
}

#tab-content {
    border-top: 1px solid #444; /* Separates tabs from content */
    padding-top: 10px;
}
#achievements-list {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

.achievement-icon {
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    border: 2px solid #444;
    border-radius: 5px;
    background-color: #3d3d3d;
    position: relative;
}

.achievement-icon.unlocked {
    border-color: #66ff66; /* Green border for unlocked achievements */
}

.achievement-icon:not(.unlocked) {
}
.achievement-icon {
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    border: 2px solid #444;
    border-radius: 5px;
    background-color: #3d3d3d;
    position: relative;
}

.achievement-icon.unlocked {
    border-color: #66ff66; /* Green border for unlocked achievements */
}

.achievement-icon:not(.unlocked)::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    pointer-events: none;
    z-index: 1;
}

.tooltip .tooltiptext {
    visibility: hidden;
    width: max-content;
    max-width: 300px;
    background-color: #2d2d2d;
    color: #fff;
    text-align: left;
    border-radius: 4px;
    padding: 8px 12px;
    position: absolute;
    z-index: 1002;
    border: 1px solid #ff6666;
    box-shadow: 0 0 5px rgba(255, 102, 102, 0.3);
    opacity: 0;
    transition: opacity 0.3s;
    white-space: normal;
    pointer-events: none;
    bottom: calc(100% + 5px);
    left: 50%;
    transform: translateX(-50%);
}

.tooltip:hover .tooltiptext {
    visibility: visible;
    opacity: 1 !important;
}
    </style>
</head>
<body>
<!-- Modals -->
<div id="raceSelectionModal" class="modal">
    <h3>Choose Your Wielder's Race</h3>
    <div id="raceOptions"></div>
    <button onclick="onModalClose('raceSelectionModal')">Close</button>
</div>
<div id="unlocksModal" class="modal">
    <h3>Next Unlocks</h3>
    <div id="unlockList"></div>
    <button onclick="onModalClose('unlocksModal')">Close</button>
</div>
<div id="statsModal" class="modal">
    <h3>Game Statistics</h3>
    <div id="statisticsContent"></div>
    <button onclick="onModalClose('statsModal')">Close</button>
</div>
<div id="optionsModal" class="modal">
    <h3>Game Options</h3>
    <textarea id="saveData" rows="5"></textarea>
    <button onclick="exportSave()">Export Save</button>
    <button onclick="importSave()">Import Save</button>
    <button onclick="onModalClose('optionsModal')">Close</button>
</div>
<div id="storyModal" class="modal">
    <h3>Sword's Legacy</h3>
    <div id="storyContent"></div>
    <button onclick="onModalClose('storyModal')">Close</button>
</div>
<div id="changelogModal" class="modal">
    <h3>Changelog</h3>
    <div id="changelogContent"></div>
    <button onclick="onModalClose('changelogModal')">Close</button>
</div>

<div id="levelUpModal" class="modal">
    <h3>Level Up!</h3>
    <p id="statPointsInfo"></p>
    <p>Choose a stat to improve:</p>
    <div class="stat-choice tooltip" onclick="allocatePoint('strength')">
        [+] Strength
        <span class="tooltiptext">Increase physical attack power</span>
    </div>
    <div class="stat-choice tooltip" onclick="allocatePoint('swordfighting')">
        [+] Swordfighting
        <span class="tooltiptext">Enhance defensive capabilities</span>
    </div>
    <div class="stat-choice tooltip" onclick="allocatePoint('endurance')">
        [+] Endurance
        <span class="tooltiptext">Increase maximum health</span>
    </div>
    <div class="stat-choice tooltip" onclick="allocatePoint('willpower')">
        [+] Willpower
        <span class="tooltiptext">Resist sword's control but gain better bonuses</span>
    </div>
</div>
<div id="wielderDeathModal" class="modal">
    <h3>Wielder Death</h3>
    <p id="wielderDeathMessage"></p>
    <p>You must select a new wielder.</p>
    <button onclick="showRaceSelection()">Select New Wielder</button>
</div>
<div id="heavyWoundModal" class="modal">
    <h3>Heavy Wound Inflicted</h3>
    <p id="heavyWoundMessage"></p>
    <button onclick="onModalClose('heavyWoundModal')">Close</button>
</div>
<!-- Game Sections -->
<div id="gameLogo" class="game-section">
    <img src="BSBTitles6.webp" class="logo-img" alt="Cursed Sword Legacy">
</div>

<div id="swordSection" class="game-section">
    <div id="swordStats">
        <h2>Sword Upgrades</h2>
        <div class="stat tooltip">
            Energy: <span id="energy">0</span>/<span id="maxEnergy">100</span>
            <span class="tooltiptext">Current/Maximum energy stored in the sword</span>
        </div>
        <div class="stat tooltip">
            Total Kills: <span id="totalKills">0</span>
            <span class="tooltiptext">Total number of enemies defeated</span>
        </div>
    </div>
    <div id="upgrades"></div>
</div>

<div id="zonesSection" class="game-section">
    <div id="tabs">
        <button class="active" onclick="showTab('zones')">Zones</button>
        <button onclick="showTab('achievements')">Achievements</button>
    </div>
    <div id="tab-content">
        <div id="zones-content">
            <h2>Zones</h2>
            <div id="enemies"></div> <!-- Existing zones content -->
        </div>
        <div id="achievements-content" style="display: none;">
            <h2>Achievements</h2>
            <div id="achievements-list"></div>
        </div>
    </div>
</div>

<div id="wielderSection" class="game-section">
    <h2>Wielder</h2>
    <div id="wielderStats"></div>
</div>

<div id="actionsSection" class="game-section">
    <h2>🎮 Actions</h2>
    <div class="action-buttons">
        <span class="tooltip">
            <button id="restButton" onclick="onActionButtonClick('resting')">Rest</button>
            <span class="tooltiptext">Recover health faster (disables other actions)</span>
        </span>
        <span class="tooltip">
            <button id="trainButton" onclick="onActionButtonClick('training')">Train</button>
            <span class="tooltiptext">Gain 2 EXP/second (disables other actions)</span>
        </span>
        <span class="tooltip">
            <button id="healButton" onclick="healWielder()">Heal wielder (10 energy)</button>
            <span class="tooltiptext">Restore 25% health for 10 energy</span>
        </span><br>
        <span class="tooltip">
            <button id="changeWielderButton" onclick="showRaceSelection()">Change Wielder </button>
            <span class="tooltiptext">Lose your current wielder permanently. Pick the race of a new one.</span>
        </span>
    </div>
</div>

<div id="combatLog" class="game-section combat-window">
    <h2>Combat Log</h2>
    <div id="combat-log" class="combat-log"></div>
</div>

<!-- Footer -->
<footer>
        <span class="tooltip">
            <a href="#" onclick="showStory()">📖</a>
            <span class="tooltiptext">View Sword's Story</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="showStatistics()">📊</a>
            <span class="tooltiptext">Game Statistics</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="showChangelog()">📜</a>
            <span class="tooltiptext">View Changelog</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="wipeSave()">❌</a>
            <span class="tooltiptext">Delete Save File</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="showOptions()">⚙️</a>
            <span class="tooltiptext">Game Options</span>
        </span>
    <span class="tooltip">
            <a href="https://caffeineforge.com" target="_blank">🐙</a>
            <span class="tooltiptext">Visit Writer's Site</span>
    </span>
    <span class="tooltip">
            <a href="https://www.royalroad.com/fiction/106967/bloodstained-blade-gamelit-sword-mc" target="_blank">🐦</a>
            <span class="tooltiptext">Read the Story</span>
        </span>
</footer>

<script>
    // Initialize variables
    const game = {
            strory1Viewed:false,
            isFighting: false,
            autoBattle: false,
            currentEnemy: null,
            controlBonus: 0,
            sword: {
                energy: 0,
                maxEnergy: 100,
                kills: 0,
                upgrades: {
                    capacity: { level: 1, cost: 50 },
                    siphon: { level: 1, cost: 100 },
                    senses: { level: 1, cost: 200 },
                    connection: { level: 1, cost: 150 },
                    control: { level: 1, cost: 300 },
                    soul: { level: 1, cost: 500 }
                }
            },
            wielder: null,
            statistics: {
                totalKills: 0,
                wieldersUsed: 0,
                mobKills: {},
                zoneKills: {}
            },
            story: [],
            unlockedUpgrades: [],
            unlockedRaces: ['human']
        };
game.achievements = {
    noviceSlayer: {
        name: "Novice Slayer",
        description: "Defeat 100 enemies",
        condition: () => game.statistics.totalKills >= 100,
        bonus: { damageMultiplier: 1.05 },
        unlocked: false,
        icon: "🗡️" // Sword icon
    },
    energyHoarder: {
        name: "Energy Hoarder",
        description: "Accumulate 1000 energy",
        condition: () => game.sword.energy >= 1000,
        bonus: { maxEnergyMultiplier: 1.10 },
        unlocked: false,
        icon: "🔋" // Battery icon
    },
    upgradeMaster: {
        name: "Upgrade Master",
        description: "Upgrade any sword upgrade to level 5",
        condition: () => Object.values(game.sword.upgrades).some(upg => upg.level >= 5),
        bonus: { upgradeCostReduction: 0.05 },
        unlocked: false,
        icon: "🔧" // Wrench icon
    },
    zoneExplorer: {
        name: "Zone Explorer",
        description: "Explore all available zones",
        condition: () => gameData.zones.every(zone => zone.unlocked),
        bonus: { expMultiplier: 1.10 },
        unlocked: false,
        icon: "🗺️" // Map icon
    },
    wielderVeteran: {
        name: "Wielder Veteran",
        description: "Have 5 different wielders",
        condition: () => game.statistics.wieldersUsed >= 5,
        bonus: { startingStats: 1 },
        unlocked: false,
        icon: "👥" // People icon
    }
};
        let lastUsedZoneIndex = 0;

        let gameData, races, zones, upgradeCaps;
        game.currentAction = null;
        function showTab(tabName) {
    const zonesContent = document.getElementById('zones-content');
    const achievementsContent = document.getElementById('achievements-content');
    const zonesButton = document.querySelector('#tabs button:nth-child(1)');
    const achievementsButton = document.querySelector('#tabs button:nth-child(2)');

    if (tabName === 'zones') {
        zonesContent.style.display = 'block';
        achievementsContent.style.display = 'none';
        zonesButton.classList.add('active');
        achievementsButton.classList.remove('active');
    } else {
        zonesContent.style.display = 'none';
        achievementsContent.style.display = 'block';
        achievementsButton.classList.add('active');
        zonesButton.classList.remove('active');
        updateAchievementsTab(); // Update achievements when switching to that tab
    }
}
function checkAchievements() {
    Object.entries(game.achievements).forEach(([key, achievement]) => {
        if (!achievement.unlocked && achievement.condition()) {
            achievement.unlocked = true;
            addCombatMessage(
                `Achievement Unlocked: ${achievement.name}! Bonus: ${getBonusDescription(achievement.bonus)}`,
                'achievement'
            );
            if (achievement.bonus.maxEnergyMultiplier) {
                calculateMaxEnergy(); // Update max energy if affected
            }
        }
    });
}
function checkAchievements() {
    Object.entries(game.achievements).forEach(([key, achievement]) => {
        if (!achievement.unlocked && achievement.condition()) {
            achievement.unlocked = true;
            addCombatMessage(
                `Achievement Unlocked: ${achievement.name}! Bonus: ${getBonusDescription(achievement.bonus)}`,
                'achievement'
            );
            if (achievement.bonus.maxEnergyMultiplier) {
                calculateMaxEnergy(); // Update max energy if affected
            }
        }
    });
}function getExpMultiplier() {
    let multiplier = 1;
    Object.values(game.achievements).forEach(ach => {
        if (ach.unlocked && ach.bonus.expMultiplier) {
            multiplier *= ach.bonus.expMultiplier;
        }
    });
    return multiplier;
}
function updateAchievementsTab() {
    const list = document.getElementById('achievements-list');
    list.innerHTML = Object.entries(game.achievements).map(([key, ach]) => `
        <div class="achievement-icon tooltip ${ach.unlocked ? 'unlocked' : ''}">
            <span>${ach.icon}</span>
            <span class="tooltiptext">
                ${ach.name}<br>
                ${ach.description}<br>
                Status: ${ach.unlocked ? 'Unlocked' : 'Locked'}<br>
                ${ach.unlocked ? `Bonus: ${getBonusDescription(ach.bonus)}` : ''}
            </span>
        </div>
    `).join('');
}

function getBonusDescription(bonus) {
    if (bonus.damageMultiplier) return `+${(bonus.damageMultiplier - 1) * 100}% damage`;
    if (bonus.maxEnergyMultiplier) return `+${(bonus.maxEnergyMultiplier - 1) * 100}% max energy`;
    if (bonus.upgradeCostReduction) return `-${bonus.upgradeCostReduction * 100}% upgrade cost`;
    if (bonus.expMultiplier) return `+${(bonus.expMultiplier - 1) * 100}% EXP gain`;
    if (bonus.startingStats) return `+${bonus.startingStats} to all starting stats`;
    return '';
}
        // Wielder Generation
        function generateWielder(race) {
            game.statistics.wieldersUsed = (game.statistics.wieldersUsed ?? 0) + 1;
            checkAchievements();
            if (!race) {
                const availableRaces = Object.keys(races).filter(r => races[r].unlocked);
                race = availableRaces[Math.floor(Math.random() * availableRaces.length)];
            }
            const raceData = races[race];
            const startingBonus = game.achievements.wielderVeteran.unlocked ? game.achievements.wielderVeteran.bonus.startingStats : 0;
            const baseStats = {
                strength: Math.floor(Math.random() * 6 + 1) + (raceData.stats.strength || 0) + startingBonus,
                swordfighting: Math.floor(Math.random() * 6 + 1) + (raceData.stats.swordfighting || 0) + startingBonus,
                endurance: Math.floor(Math.random() * 2 + 1) + (raceData.stats.endurance || 0) + startingBonus,
                willpower: Math.floor(Math.random() * 50 + 50) + (raceData.stats.willpower || 0) + startingBonus
            };
            return {
                name: raceData.names[Math.floor(Math.random() * raceData.names.length)],
                race,
                baseStats: { ...baseStats },
                currentStats: { ...baseStats },
                wounds: [],
                level: 1,
                statPoints: 0,
                exp: 0,
                currentLife: baseStats.endurance * 5,
                resting: false,
                training: false,
                defeated: false
            };
        }

        // Action Handling
        function onActionButtonClick(actionType) {
            const buttons = ['restButton', 'trainButton'];
            buttons.forEach(id => document.getElementById(id).classList.remove('active-action'));

            switch (actionType) {
                case 'resting':
                    game.currentAction = game.currentAction === 'resting' ? null : 'resting';
                    if (game.currentAction) document.getElementById('restButton').classList.add('active-action');
                    break;
                case 'training':
                    game.currentAction = game.currentAction === 'training' ? null : 'training';
                    if (game.currentAction) document.getElementById('trainButton').classList.add('active-action');
                    break;

            }
            updateDisplay();
        }

        function startAutoBattle() {
    if (!isAnyModalOpen()) {
        if (!gameData.zones[lastUsedZoneIndex]) lastUsedZoneIndex = 0;
        const zone = gameData.zones[lastUsedZoneIndex];
        const enemyIndex = Math.floor(Math.random() * zone.enemies.length);
        attackEnemy(lastUsedZoneIndex, enemyIndex);
    }
}

        function healWielder() {
            if (game.sword.energy >= 10 && game.wielder.currentLife < game.wielder.currentStats.endurance*5) {
                game.sword.energy -= 10;
                game.wielder.currentLife = Math.min(
                    game.wielder.currentLife + Math.floor(game.wielder.currentStats.endurance * 1.25),
                    game.wielder.currentStats.endurance*5
                );
                updateDisplay();
            }
        }

        // Display Updates
        function getWoundText(stat) {
            const count = game.wielder.wounds.filter(w => w === stat).length;
            return count > 0 ? `\n(Wounded: -${count})` : '';
        }
function updateCombatStats() {
    const wielder = game.wielder;

    // Update HP
    const hpElement = document.querySelector('#wielderStats .stat:nth-child(5)'); // Assuming HP is 5th stat
    if (hpElement) {
        hpElement.innerHTML = `
            HP: ${Math.max(wielder.currentLife, 0)}/${wielder.currentStats.endurance*5}
            <span class="tooltiptext">Current/Maximum health (Regenerates 1 HP every 5s)</span>
        `;
    }

    // Update EXP
    const expElement = document.querySelector('#wielderStats .stat:nth-child(7)'); // Assuming EXP is 7th stat
    if (expElement) {
        expElement.innerHTML = `
            EXP: ${Math.round(wielder.exp)}/${wielder.level * 100}
            <span class="tooltiptext">Gain a level every 100 exp points</span>
        `;
    }

    // Update Energy
    document.getElementById('energy').textContent = `${game.sword.energy.toFixed(1)} / ${game.sword.maxEnergy.toFixed(1)}`;

    // Update Total Kills
    document.getElementById('totalKills').textContent = game.statistics.totalKills;
}
        function updateDisplay() {

            const wielder = game.wielder;
            const baseDamage = wielder.currentStats.strength * 2 + wielder.currentStats.swordfighting;
            const controlDamageBonus = baseDamage * game.controlBonus;
            const lifesteal = game.sword.upgrades.siphon.level;
            const totalDamage = (baseDamage + lifesteal + controlDamageBonus) * getDamageMultiplier();
            game.controlBonus = game.sword.upgrades.control.level * 0.2 * (1 - Math.min(wielder.currentStats.willpower, 200) / 200);
            document.getElementById('wielderStats').innerHTML = `
    <div class="stat">Name: <span id="wielderName">${wielder.name}</span></div>
    <div class="stat">Race: <span id="wielderRace">${wielder.race}</span></div>
    <div class="stat tooltip">
        Strength: ${wielder.currentStats.strength}${wielder.baseStats.strength > wielder.currentStats.strength ? '⚠' : ''}
        <span class="tooltiptext">Increases damage dealt per strike (+2 Damage)${getWoundText('strength')}</span>
    </div><br />
    <div class="stat tooltip">
        Swordfighting: ${wielder.currentStats.swordfighting}${wielder.baseStats.swordfighting > wielder.currentStats.swordfighting ? '⚠' : ''}
        <span class="tooltiptext">Reduces incoming damage (+1 resistance) Increases damage (+1)${getWoundText('swordfighting')}</span>
    </div><br />
    <div class="stat tooltip">
        Endurance: ${wielder.currentStats.endurance}
        <span class="tooltiptext">Determines maximum health (HP = Endurance × 5)</span>
    </div><br />
    <div class="stat tooltip">
        HP: ${Math.max(wielder.currentLife, 0)}/${wielder.currentStats.endurance*5}
        <span class="tooltiptext">Current/Maximum health (Regenerates 1 HP every 5s)</span>
    </div><br />
    <div class="stat tooltip">
        Willpower: ${wielder.currentStats.willpower}${wielder.baseStats.willpower > wielder.currentStats.willpower ? '⚠' : ''}
        <span class="tooltiptext">Increases exp gain, reduces control (up to 100% at 200)${getWoundText('willpower')}</span>
    </div><br />
    <div class="stat tooltip">
        EXP: ${Math.round(wielder.exp)}/${wielder.level * 100}
        <span class="tooltiptext">Gain a level every 100 exp points</span>
    </div><br />
    <div class="stat tooltip">
        Level: ${wielder.level}
    </div><br />
    <div class="stat tooltip">
        Predicted Damage: ${totalDamage.toFixed(1)}
        <span class="tooltiptext">
            Base: ${baseDamage} (Strength: ${wielder.currentStats.strength} × 2 + Swordfighting: ${wielder.currentStats.swordfighting})<br>
            Control Bonus: +${(baseDamage * game.controlBonus).toFixed(1)} (${(game.controlBonus * 100).toFixed(0)}%)<br>
            Lifesteal: +${game.sword.upgrades.siphon.level} damage & HP per hit
        </span>
    </div>
`;
            // Button state management
                const healButton = document.getElementById('healButton');
                const changeWielderButton = document.getElementById('changeWielderButton');
                const restButton = document.getElementById('restButton');
                const trainButton = document.getElementById('trainButton');

                if (game.wielder.defeated) {
                    // This block will be updated in Step 2
                    restButton.disabled = true;
                    trainButton.disabled = true;
                    healButton.disabled = true;
                    changeWielderButton.disabled = false;
                } else {
                    restButton.disabled = false;
                    trainButton.disabled = false;
                    healButton.disabled = game.sword.energy < 10 || game.wielder.currentLife >= game.wielder.currentStats.endurance*5;
                    changeWielderButton.disabled = false;
                }
            document.getElementById('energy').textContent = Math.floor(game.sword.energy);
            document.getElementById('maxEnergy').textContent = game.sword.maxEnergy;
            document.getElementById('totalKills').textContent = game.statistics.totalKills;

            document.getElementById('upgrades').innerHTML = Object.entries(game.sword.upgrades)
                .map(([name, data]) => `
                    <div class="upgrade tooltip">
                        ${name.charAt(0).toUpperCase() + name.slice(1)} (Level ${data.level})
                        <span class="tooltiptext">${getUpgradeTooltip(name)}</span>
                        <button onclick="buyUpgrade('${name}')" ${game.sword.energy >= data.cost ? '' : 'disabled'}>
                            Upgrade (${Math.round(data.cost)} energy)
                        </button>
                    </div>
                `)
                .join('');

            document.getElementById('enemies').innerHTML = gameData.zones
    .filter(zone => zone.unlocked)
    .map((zone, zi) => `
        <div class="zone">
            <h4>${zone.name}</h4>
            <span class="tooltip">
                            <button class="explore-btn" onclick="exploreZone(${zi})">Explore</button>
                            <span class="tooltiptext">
                                Possible enemies:<br>
                                ${zone.enemies.map(e => `${e.name} (Lv. ${e.level}, ${e.endurance*5} HP)`).join('<br>')}
                            </span>
                        </span>
            <span class="autofight">
                <input type="checkbox" id="auto-${zi}" onchange="toggleAutoFight(${zi})"
                    ${game.currentAction === 'autoFighting' && lastUsedZoneIndex === zi ? 'checked' : ''}
                    ${game.sword.upgrades.connection.level < zi + 1 || (game.currentAction && game.currentAction !== 'autoFighting') ? 'disabled' : ''}>
                <label for="auto-${zi}">Auto explore</label>
            </span>

        </div>
    `)
    .join('');

            const actionInProgress = !!game.currentAction;
            document.querySelectorAll('#enemies button').forEach(btn => {
                btn.disabled = actionInProgress || game.wielder.defeated;
            });
            gameData.zones.forEach((_, zi) => {
                const checkbox = document.getElementById(`auto-${zi}`);
                if (checkbox) {
                    checkbox.disabled = game.sword.upgrades.connection.level < zi + 1 || game.wielder.defeated || (game.currentAction && game.currentAction !== 'autoFighting');
                }
            });

        }
// Explore Zone Logic
        function exploreZone(zoneIndex) {
            if (game.currentAction && game.currentAction !== 'autoFighting') return;
            lastUsedZoneIndex = zoneIndex;
            const enemyIndex = Math.floor(Math.random() * gameData.zones[zoneIndex].enemies.length);
            attackEnemy(zoneIndex, enemyIndex);
        }

        // Toggle Autofight
        function toggleAutoFight(zoneIndex) {
            const checkbox = document.getElementById(`auto-${zoneIndex}`);
            if (checkbox.checked) {
                gameData.zones.forEach((_, i) => {
                    if (i !== zoneIndex && document.getElementById(`auto-${i}`) != null) document.getElementById(`auto-${i}`).checked = false;
                });
                game.currentAction = 'autoFighting';
                lastUsedZoneIndex = zoneIndex;

                startAutoBattle();
            } else {
                game.currentAction = null;

            }
            updateDisplay();
        }
        function getUpgradeTooltip(name) {
            const tooltips = {
                capacity: 'Increases maximum energy',
                siphon: 'Adds 1 lifesteal per level',
                senses: 'Unlocks stronger enemies',
                connection: 'Improves bond with the wielder, unlocks additional mechanics, increases passive health regen',
                control: 'Increases damage bonus (20% at 0 willpower, 0% at 200+ willpower per level)',
                soul: 'Discover more of your history'
            };
            return tooltips[name] || '';
        }

        // Combat Logic
        function calculateExpGain(baseExp) {
            const enemy = gameData.zones[game.currentEnemy.zoneIndex].enemies[game.currentEnemy.enemyIndex];
            const levelDiff = enemy.level - game.wielder.level;
            const expMultiplier = 1 + (levelDiff * 0.2);
            const expGained = Math.max(Math.floor(baseExp * expMultiplier), 0) * (1 + game.wielder.currentStats.willpower / 200);
            addCombatMessage(`Gained ${expGained.toFixed(1)} exp. ${(expMultiplier * 100).toFixed(2)}% of base due to level gap.`, 'player-stat');
            return expGained;
        }
function getMaxEnergyMultiplier() {
    let multiplier = 1;
    Object.values(game.achievements).forEach(ach => {
        if (ach.unlocked && ach.bonus.maxEnergyMultiplier) {
            multiplier *= ach.bonus.maxEnergyMultiplier;
        }
    });
    return multiplier;
}

function calculateMaxEnergy() {
    let base = 100; // Base max energy
    base *= Math.pow(2, game.sword.upgrades.capacity.level-1); // Apply capacity upgrade
    base *= getMaxEnergyMultiplier(); // Apply achievement bonuses
    game.sword.maxEnergy = base;
}
function getUpgradeCostReduction() {
    let reduction = 0;
    Object.values(game.achievements).forEach(ach => {
        if (ach.unlocked && ach.bonus.upgradeCostReduction) {
            reduction += ach.bonus.upgradeCostReduction;
        }
    });
    return reduction;
}
        async function attackEnemy(zoneIndex, enemyIndex) {
            if (game.currentAction && game.currentAction !== 'autoFighting') return;
            lastUsedZoneIndex = zoneIndex;
            const wielder = game.wielder;
            game.isFighting = true;
            game.currentEnemy = { zoneIndex, enemyIndex };
            const enemy = gameData.zones[zoneIndex].enemies[enemyIndex];
            let enemyLife = enemy.endurance*5;

            if (wielder.currentLife <= 0) {
                addCombatMessage('Wielder is too injured to fight!', 'damage');
                game.isFighting = false;
                updateDisplay();
                return;
            }

            const controlLevel = game.sword.upgrades.control.level;
            const willpower = Math.min(wielder.currentStats.willpower, 200); // Cap at 200
            game.controlBonus = controlLevel * 0.2 * (1 - willpower / 200); // 20% at 0 willpower, 0% at 200+

            const baseDamage = wielder.currentStats.strength * 2 + wielder.currentStats.swordfighting;
    const controlDamageBonus = baseDamage * game.controlBonus;
    const lifesteal = game.sword.upgrades.siphon.level; // 1 lifesteal per level
    const damageMultiplier = getDamageMultiplier();
    const totalDamage = (baseDamage + lifesteal + controlDamageBonus) * damageMultiplier;
    addCombatMessage(`Engaging ${enemy.name} (${enemy.endurance*5} HP)`, 'player-stat');

    while (enemyLife > 0 && wielder.currentLife > 0 && !isAnyModalOpen()) {
        const damageDealt = Math.min(totalDamage, enemyLife);
        const lifestealHealing = Math.min(lifesteal, enemyLife); // Can't heal more than damage dealt
        enemyLife -= damageDealt;
        wielder.currentLife = Math.min(
            wielder.currentStats.endurance*5,
            wielder.currentLife + lifestealHealing
        );

        addCombatMessage(
            `Dealt ${damageDealt.toFixed(1)} damage (Base: ${baseDamage}, Control: ${controlDamageBonus.toFixed(1)}) ` +
            `Lifesteal: +${lifestealHealing} HP | Enemy HP: ${enemyLife}`,
            'damage'
        );
        const enemyDamage = Math.max(enemy.strength * 2 -
         Math.floor(game.wielder.currentStats.swordfighting), 1);
         game.wielder.currentLife -= enemyDamage;

                 addCombatMessage(`Took ${enemyDamage} damage ` +
                     `(Base: ${enemy.strength*2}, Defense: ` +
                     `${Math.floor(game.wielder.currentStats.swordfighting )})` +
                     `Player Hp left: ${game.wielder.currentLife}`, 'damage');
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            if (isAnyModalOpen()) {
        addCombatMessage('Combat paused due to open menu.', 'player-stat');
        game.isFighting = false; // Reset fighting state
        return;
    }
            if (wielder.currentLife <= 0) {
                addCombatMessage('Lost the fight! Disengaging. Rest or heal.', 'damage');

                if (game.currentAction === 'autoFighting') onActionButtonClick('autoFighting');
                applyHeavyWound();
                game.isFighting = false;
                updateDisplay();
                return;
            }
            if (enemyLife <= 0) {
                const energyGain = enemy.endurance*5 * (1 + game.sword.upgrades.siphon.level * 0.1);
                game.sword.energy = Math.min(game.sword.energy + energyGain, game.sword.maxEnergy);
                addCombatMessage(`${enemy.name} defeated! +${energyGain.toFixed(1)} energy`, 'enemy-defeated');

                const expGained = calculateExpGain(enemy.exp);
                wielder.exp += expGained;
                game.statistics.zoneKills[zoneIndex] = (game.statistics.zoneKills[zoneIndex] ?? 0) + 1;
                game.statistics.totalKills = (game.statistics.totalKills ?? 0) + 1;
                game.statistics.mobKills[enemy.name] = (game.statistics.mobKills[enemy.name] ?? 0) + 1;
                checkAchievements();
                while (wielder.exp >= wielder.level * 100) {
                    wielder.exp -= wielder.level * 100;
                    wielder.level++;
                    wielder.statPoints += calculateStatPointsPerLevel();
                    applyLevelBonuses(); // Apply race-specific bonuses
                    showLevelUpModal();
                }
                game.isFighting = false;
                if (game.currentAction === 'autoFighting') startAutoBattle();
            }


            updateDisplay();
        }
        function getUpgradeCostReduction() {
    let reduction = 0;
    Object.values(game.achievements).forEach(ach => {
        if (ach.unlocked && ach.bonus.upgradeCostReduction) {
            reduction += ach.bonus.upgradeCostReduction;
        }
    });
    return reduction;
}
function getDamageMultiplier() {
    let multiplier = 1;
    Object.values(game.achievements).forEach(ach => {
        if (ach.unlocked && ach.bonus.damageMultiplier) {
            multiplier *= ach.bonus.damageMultiplier;
        }
    });
    return multiplier;
}
function updateUpgrades() {
    const upgradesDiv = document.getElementById('upgrades');
    const costReduction = getUpgradeCostReduction();
    upgradesDiv.innerHTML = Object.entries(game.sword.upgrades).map(([name, upg]) => {
        const effectiveCost = upg.cost * (1 - costReduction);
        return `<button onclick="buyUpgrade('${name}')">${name} (Level ${upg.level}) - Cost: ${effectiveCost.toFixed(1)}</button>`;
    }).join('');
}
        function isAnyModalOpen() {
    const modals = [
        'raceSelectionModal',
        'unlocksModal',
        'statsModal',
        'optionsModal',
        'storyModal',
        'changelogModal',
        'levelUpModal',
        'wielderDeathModal',
        'heavyWoundModal'
    ];
    return modals.some(id => document.getElementById(id).style.display === 'block');
}
        function calculateStatPointsPerLevel() {
    const race = game.wielder.race;
    const basePoints = gameData.races[race].skillpoints ; // Default to 1 if not specified
    return basePoints;
}
        // Level Up
        function showLevelUpModal() {
            updateStatPointsInfo();
            document.getElementById('levelUpModal').style.display = 'block';
        }
        function applyLevelBonuses() {
            const race = game.wielder.race;
            const levelBonuses = gameData.races[race].levelBonuses || {};
            for (const [stat, bonus] of Object.entries(levelBonuses)) {
                game.wielder.currentStats[stat] += bonus;
                if (stat === 'enduranec') {
                    game.wielder.currentLife += bonus; // Increase current HP when max HP increases
                }
            }
        }
        function allocatePoint(stat) {
            game.wielder.currentStats[stat]++;
            game.wielder.statPoints--;
            if (stat === 'endurance') {
                game.wielder.currentLife += 5;
            }

            if (stat === 'willpower') game.wielder.currentStats.willpower += 4;
            if (game.wielder.statPoints <= 0) onModalClose('levelUpModal');
            updateStatPointsInfo();
            updateDisplay();
        }
function applyHeavyWound() {
    const stats = ['strength', 'swordfighting', 'willpower'];
    const affectedStat = stats[Math.floor(Math.random() * stats.length)];
    game.wielder.wounds.push(affectedStat);
    const woundCount = game.wielder.wounds.length;
    game.wielder.currentStats[affectedStat] = Math.max(
        game.wielder.baseStats[affectedStat] - game.wielder.wounds.filter(w => w === affectedStat).length,
        1
    );
    let message = `Heavy wound inflicted! Permanent -1 to ${affectedStat}. This is the ${woundCount}${['st', 'nd', 'rd'][woundCount - 1] || 'th'} wound.`;
    if (woundCount < 3) {
        message += ` If they receive a 3rd wound, they will die.`;
        addCombatMessage(message, 'damage');
        document.getElementById('heavyWoundMessage').textContent = message;
        document.getElementById('heavyWoundModal').style.display = 'block';
    } else {
        handleWielderDeath(affectedStat);
    }
    updateDisplay();
}
function handleWielderDeath(affectedStat) {
    game.wielder.defeated = true;
    game.currentAction = null; // Stop any ongoing actions
    game.sword.energy = 0;
    const message = affectedStat
        ? `Your wielder has succumbed to their wounds after receiving a heavy wound to ${affectedStat}.`
        : 'Your wielder has died from their wounds.';
    addCombatMessage(message, 'damage');
    document.getElementById('wielderDeathMessage').textContent = message;
    document.getElementById('wielderDeathModal').style.display = 'block';
    updateDisplay();
}
        // UI Functions
        function showRaceSelection() {
                        document.getElementById('wielderDeathModal').style.display = 'none';

            const modal = document.getElementById('raceSelectionModal');
            gameData.zones = gameData.zones.map((zone, index) => ({
                ...zone,
                unlockRace: Object.keys(races).find(race => races[race].unlockRequirement?.zone === index)
            }));

            let content = '<div class="race-list">';
            Object.entries(races).forEach(([raceKey, raceData]) => {
                const zone = gameData.zones[raceData.unlockRequirement?.zone];
                const kills = raceData.unlockRequirement ? (game.statistics.zoneKills[raceData.unlockRequirement.zone] || 0) : 0;
                const required = raceData.unlockRequirement?.kills || 0;
                raceData.unlocked = raceData.unlocked || kills >= required; // Ensure unlocked status persists

                const baseRanges = {
                    strength: { min: 1, max: 6 },
                    swordfighting: { min: 1, max: 6 },
                    endurance: { min: 10, max: 15 },
                    willpower: { min: 75, max: 125 }
                };
                const statRanges = ['strength', 'swordfighting', 'endurance', 'willpower'].map(stat => {
                    const bonus = raceData.stats[stat] || 0;
                    const levelBonus = raceData.levelBonuses?.[stat] || 0;
                    const base = baseRanges[stat];
                    return { stat, min: base.min + bonus, max: base.max + bonus, levelBonus };
                });

                // Conditionally apply .tooltip class only if the race is unlocked
                const tooltipClass = raceData.unlocked ? 'tooltip' : '';

                content += `
                    <div onclick="selectRace('${raceKey}')" class="race-option ${raceData.unlocked ? '' : 'locked'} ${tooltipClass}">
                        <h4>${raceKey.toUpperCase()}</h4>
                        <div class="stats">
                            ${statRanges.map(({ stat, min, max, levelBonus }) => `
                                ${stat}: ${min}-${max} (+${levelBonus}/lvl)
                            `).join(' | ')}
                        </div>
                        ${!raceData.unlocked ? `
                            <div class="unlock-requirement">
                                ${required} ${zone?.name} kills (${kills}/${required})
                            </div>
                        ` : ''}
                        ${raceData.unlocked ? `
                            <span class="tooltiptext">
                                Starting ranges and per-level bonuses:<br>
                                ${statRanges.map(({ stat, min, max, levelBonus }) => `
                                    ${stat}: ${min}-${max} (Base: ${baseRanges[stat].min}-${baseRanges[stat].max}, Bonus: ${raceData.stats[stat] || 0}) +${levelBonus}/level
                                `).join('<br>')}
                            </span>
                        ` : ''}
                    </div>
                `;
            });
            content += '</div>';
            document.getElementById('raceOptions').innerHTML = content;
            modal.style.display = 'block';
            adjustTooltipPosition(); // Ensure tooltips are positioned correctly after rendering
        }
function onModalClose(modalId) {
    document.getElementById(modalId).style.display = 'none';
    if (game.currentAction === 'autoFighting' && !game.isFighting && !isAnyModalOpen()) {
        startAutoBattle();
    }
    updateDisplay();
}
        function selectRace(race) {
            if ( races[race].unlocked) {
                game.wielder = generateWielder(race);
                document.getElementById('raceSelectionModal').style.display = 'none';
                updateDisplay();
            }
        }

        function showStatistics() {
            document.getElementById('statisticsContent').innerHTML = `
                <p>Total Kills: ${game.statistics.totalKills}</p>
                <p>Wielders Used: ${game.statistics.wieldersUsed}</p>
                <h4>Kills by Enemy:</h4>
                ${Object.entries(game.statistics.mobKills).map(([mob, count]) => `<p>${mob}: ${count}</p>`).join('')}
            `;
            document.getElementById('statsModal').style.display = 'block';
        }

        function addCombatMessage(text, className) {
            const logElement = document.createElement('div');
            logElement.className = `log-entry ${className}`;
            logElement.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
            const combatLog = document.getElementById('combat-log');
            combatLog.appendChild(logElement);
            if (combatLog.children.length > 50) combatLog.removeChild(combatLog.firstChild);
            combatLog.scrollTop = combatLog.scrollHeight;
        }
        function updateStatPointsInfo() {

    const race = game.wielder.race;
    const basePoints = gameData.races[race].skillpoints || 1;

    const totalPoints = game.wielder.statPoints;
    const info = `You have ${totalPoints} stat points to allocate. ` +
                 `(Each level grants ${basePoints} point.)`;
    document.getElementById('statPointsInfo').textContent = info;
}

        // Upgrades and Story
        function buyUpgrade(upgradeName) {
            const cap = gameData.upgradeCaps[upgradeName];
            const upgrade = game.sword.upgrades[upgradeName];
            const costReduction = getUpgradeCostReduction();
            const effectiveCost = upgrade.cost * (1 - costReduction);
            if (upgrade.level >= cap) {
                addCombatMessage(`Maximum ${upgradeName} level reached!`, 'damage');
                return;
            }
            if (game.sword.energy >= effectiveCost) {
                game.sword.energy -= effectiveCost;
                upgrade.level++;
                upgrade.cost *= 2;
                if (upgradeName === 'capacity') calculateMaxEnergy();
                if (upgradeName === 'senses') gameData.zones[upgrade.level - 1].unlocked = true;
                if (upgradeName === 'soul') {
                    unlockNextStory();
                    showStory();
                }
                updateDisplay();
                checkAchievements();
            }
        }

        function unlockNextStory() {
            const stories = gameData.story;
            const nextLockedStory = Object.entries(stories).find(([_, story]) => !story.unlocked);
            if (nextLockedStory) {
                const [storyKey] = nextLockedStory;
                stories[storyKey].unlocked = true;
                return true;
            }
            return false;
        }

        function showStory(vieved) {
            if (vieved) {
                if(!game.story1Vieved) showStory();
                game.story1Vieved = true;
                return;
            }
            const stories = Object.values(gameData.story).filter(story => story.unlocked);
            document.getElementById('storyContent').innerHTML = stories.length > 0
                ? stories.map(story => `<div class="story-entry"><h4>${story.title}</h4><p>${story.entry.join('</p><p>')}</p></div>`).join('')
                : '<p>No story fragments unlocked yet</p>';
            document.getElementById('storyModal').style.display = 'block';
        }

        // Save System
        function saveGame() {
        console.log('Saved game');
            const saveData = { game, wielder: game.wielder, timestamp: Date.now(), gameData };
            localStorage.setItem('cursedSwordSave', JSON.stringify(saveData));
        }

        function loadGame() {
        console.log('Loading game');
            const saved = localStorage.getItem('cursedSwordSave');
            if (saved) {
                const saveData = JSON.parse(saved);
                const { achievements, ...gameDataToAssign } = saveData.game;
                Object.assign(game, gameDataToAssign);
                game.wielder = saveData.wielder;
                gameData = saveData.gameData;
                const temp = game.currentAction;
                game.currentAction = null;
                onActionButtonClick(temp);
                game.currentAction = temp;
            } else {
                game.wielder = generateWielder(null);
            }
        }



        // Footer Functions
        function showChangelog() {
            document.getElementById('changelogContent').innerHTML = `
                <p>v1.2 - Added Save System & Wounds</p>
                <p>v1.1 - Zone Combat System</p>
                <p>v1.0 - Base Game</p>
            `;
            document.getElementById('changelogModal').style.display = 'block';
        }

        function wipeSave() {
            if (confirm('Permanently delete all progress?')) {
                localStorage.removeItem('cursedSwordSave');
                location.reload();
            }
        }

        function showOptions() {
            document.getElementById('optionsModal').style.display = 'block';
            document.getElementById('saveData').value = '';
        }

        function exportSave() {
            const saveData = { game, timestamp: Date.now(), version: 1.2 };
            document.getElementById('saveData').value = JSON.stringify(saveData, null, 2);
        }

        function importSave() {
            try {
                const importData = JSON.parse(document.getElementById('saveData').value);
                if (importData.version !== 1.2) throw new Error('Invalid version');
                Object.keys(game).forEach(key => {
                    if (importData.game[key]) game[key] = importData.game[key];
                });
                updateDisplay();
                alert('Save imported successfully!');
            } catch (e) {
                alert(`Import failed: ${e.message}`);
            }
        }

        // Game Initialization
        async function initGame() {
            gameData = await fetch('gameData.json').then(r => r.json());
            races = gameData.races;
            zones = gameData.zones;
            upgradeCaps = gameData.upgradeCaps;
            loadGame();
            saveGame();
            calculateMaxEnergy();
            updateDisplay();

            setInterval(() => {
                if (game.wielder.currentLife < game.wielder.currentStats.endurance*5) {
                    const regenRate = game.currentAction === 'resting' ? 5 : 1;
                    game.wielder.currentLife = Math.min(
                        game.wielder.currentLife + regenRate,
                        game.wielder.currentStats.endurance*5
                    );
                }
                if (game.currentAction === 'training') {
                    game.wielder.exp += 5;
                    if (game.wielder.exp >= 100 * game.wielder.level) {
                        game.wielder.exp -= 100 * game.wielder.level;
                        game.wielder.level++;
                        game.wielder.statPoints += calculateStatPointsPerLevel();
                        applyLevelBonuses(); // Apply race-specific bonuses
                        showLevelUpModal();
                    }
                }
                updateDisplay();
                saveGame();
            }, 5000);
            showStory(true);

        }
function adjustTooltipPosition() {
            document.querySelectorAll('.tooltip').forEach(tooltip => {
                const tooltipText = tooltip.querySelector('.tooltiptext');
                if (!tooltipText) return;

                // Reset any inline styles from previous adjustments
                tooltipText.style.top = '';
                tooltipText.style.bottom = '';
                tooltipText.style.left = '50%';
                tooltipText.style.transform = 'translateX(-50%)';

                // Get bounding rectangles
                const tooltipRect = tooltipText.getBoundingClientRect();
                const triggerRect = tooltip.getBoundingClientRect();
                const viewportHeight = window.innerHeight;

                // Check if tooltip would be cut off above
                if (triggerRect.top - tooltipRect.height < 0) {
                    // Position below instead
                    tooltipText.style.top = 'calc(100% + 5px)';
                    tooltipText.style.bottom = 'auto';
                } else if (triggerRect.bottom + tooltipRect.height > viewportHeight) {
                    // Ensure it doesn't go below viewport bottom
                    tooltipText.style.bottom = 'calc(100% + 5px)';
                    tooltipText.style.top = 'auto';
                }

                // Adjust horizontal overflow
                if (tooltipRect.left < 0) {
                    tooltipText.style.left = '0';
                    tooltipText.style.transform = 'translateX(0)';
                } else if (tooltipRect.right > window.innerWidth) {
                    tooltipText.style.left = 'auto';
                    tooltipText.style.right = '0';
                    tooltipText.style.transform = 'translateX(0)';
                }
            });
        }



        // Hook into updateDisplay to adjust tooltips after UI changes
        const originalUpdateDisplay = updateDisplay;
        updateDisplay = function() {
            originalUpdateDisplay();
            adjustTooltipPosition();
        };
        window.onload = initGame;
    </script>
</body>
</html>
