<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cursed Sword Idle</title>
    <style>
        :root {
            --logo-row-height: auto;
            --combat-row-height: 25%;
        }

        /* Grid Layout */
        body {
            display: grid;
            grid-template:
                "logo    wielder  zones"    var(--logo-row-height)
                "sword   wielder  zones"    0.8fr
                "sword   actions  zones"    0.7fr
                "combat  combat   combat"   var(--combat-row-height)
                / 33%    33%      auto;
            height: 100vh;
            margin: 0;
            padding: 20px;
            gap: 15px;
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }

        /* General Styling */
        .game-section {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            overflow: auto;
        }

        button {
            background-color: #4a0000;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        /* Grid Sections */
        #gameLogo {
            grid-area: logo;
            text-align: center;
        }

        #swordSection {
            grid-area: sword;
        }

        #wielderSection {
            grid-area: wielder;
        }

        #zonesSection {
            grid-area: zones;
        }

        #actionsSection {
            grid-area: actions;
        }

        #combatLog {
            grid-area: combat;
        }

        /* Specific Components */
        .logo-img {
            height: 80px;
            margin-bottom: 10px;
        }

        .stat {
            margin: 5px 0;
        }

        .upgrade button{
            order: 2; /* Move button to right side */
            min-width: 120px;
        }
        .upgrade {
            display: flex !important;
            justify-content: space-between;
            align-items: center;
            width:330px;
            background-color: #3d3d3d;
            padding: 6px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .zone {
            background-color: #3d3d3d;
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
        }

        .zone h4 {
            margin: 0 0 10px 0;
            color: #ff6666;
        }

        .zone button:hover {
            background-color: #5a0000;
        }

        .combat-log {
            font-family: "Courier New", monospace;
            font-size: 0.9em;
            display: flex;
            flex-direction: column-reverse;
        }

        .log-entry {
            margin: 3px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .damage {
            background-color: #4a000055;
            color: #ff6666;
        }

        .player-stat {
            background-color: #004a0055;
            color: #66ff66;
        }

        .enemy-defeated {
            background-color: #4a4a0055;
            color: #ffff66;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #3d3d3d;
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .stat-choice {
            margin: 10px;
            padding: 10px;
            background: #4a0000;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .stat-choice:hover {
            background: #5a0000;
        }

        /* Tooltips */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
.game-section, .modal {
            overflow: visible; /* Prevent clipping of tooltips */
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: max-content;
            max-width: 200px;
            background-color: #2d2d2d;
            color: #fff;
            text-align: center;
            border-radius: 4px;
            padding: 5px 8px;
            position: absolute;
            z-index: 1002;
            border: 1px solid #ff6666;
            box-shadow: 0 0 5px rgba(255, 102, 102, 0.3);
            bottom: 100%;
            left: 0%;
            right:0%;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Footer */
        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            background: #2d2d2d;
            text-align: center;
        }

        footer a {
            color: white;
            font-size: 24px;
            margin: 0 15px;
            text-decoration: none;
        }

        footer .tooltip .tooltiptext {
            bottom: auto;
            top: -10px;
            transform: translate(-50%, -100%);
        }

        /* Race Selection */
        .race-list {
            display: grid;
            gap: 15px;
        }

        .race-option {
            border: 1px solid #444;
            padding: 10px;
            margin: 10px 0;
            cursor: pointer;
        }

        .locked {
            opacity: 0.6;
            filter: grayscale(0.8);
        }

        .unlock-requirement {
            font-size: 0.9em;
            color: #ff6666;
            margin-top: 8px;
        }

        .stats {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 5px 0;
        }

        .race-option .stat {
            background: #3d3d3d;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #4a0000;
        }

        /* Action Buttons */
        .active-action {
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        /* Story Modal */
        .story-entry {
            border-left: 3px solid #4a0000;
            padding-left: 10px;
            margin: 10px 0;
        }
        .race-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            cursor: pointer;
            border: 1px solid #444;
        }
        .race-option .stats {
            flex-grow: 1;
            margin-left: 10px;
        }
        .zone {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .zone .explore-btn {
            flex-grow: 0;
        }
        .zone .autofight {
            margin-left: 10px;
        }


        /* Tooltip container */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        /* Tooltip text */
        .tooltip .tooltiptext {
            visibility: hidden;
            width: max-content;
            max-width: 300px; /* Increased from 200px to allow more content */
            background-color: #2d2d2d;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 8px 12px;
            position: absolute;
            z-index: 1002; /* Already high, but ensure it‚Äôs above everything */
            border: 1px solid #ff6666;
            box-shadow: 0 0 5px rgba(255, 102, 102, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal; /* Allow text to wrap */
            pointer-events: none; /* Prevent tooltip from interfering with clicks */
        }

        /* Default position: above the element */
        .tooltip .tooltiptext {
            bottom: calc(100% + 5px); /* Space above the element */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
        }

        /* Show tooltip on hover */
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Footer tooltips (positioned above due to fixed bottom) */
        footer .tooltip .tooltiptext {
            top: auto;
            bottom: calc(100% + 5px); /* Ensure it appears above the footer */
            transform: translateX(-50%);
        }
        .autofight {
        display: inline-block;
        margin-left: 10px;
    }
    .autofight input[type="checkbox"] {
        display: none;
    }
    .autofight label {
        cursor: pointer;
        padding: 5px 10px;
        background-color: #4a0000;
        border-radius: 4px;
        color: white;
    }
    .autofight input[type="checkbox"]:checked + label {
        background-color: #00ff00;
        color: #000;
    }
    </style>
</head>
<body>
<!-- Modals -->
<div id="raceSelectionModal" class="modal">
    <h3>Choose Your Wielder's Race</h3>
    <div id="raceOptions"></div>
    <button onclick="this.parentElement.style.display='none'">Close</button>
</div>

<div id="unlocksModal" class="modal">
    <h3>Next Unlocks</h3>
    <div id="unlockList"></div>
    <button onclick="this.parentElement.style.display='none'">Close</button>
</div>

<div id="statsModal" class="modal">
    <h3>Game Statistics</h3>
    <div id="statisticsContent"></div>
    <button onclick="this.parentElement.style.display='none'">Close</button>
</div>

<div id="optionsModal" class="modal">
    <h3>Game Options</h3>
    <textarea id="saveData" rows="5"></textarea>
    <button onclick="exportSave()">Export Save</button>
    <button onclick="importSave()">Import Save</button>
    <button onclick="this.parentElement.style.display='none'">Close</button>
</div>

<div id="storyModal" class="modal">
    <h3>Sword's Legacy</h3>
    <div id="storyContent"></div>
    <button onclick="this.parentElement.style.display='none'">Close</button>
</div>

<div id="changelogModal" class="modal">
    <h3>Changelog</h3>
    <div id="changelogContent"></div>
    <button onclick="this.parentElement.style.display='none'">Close</button>
</div>

<div id="levelUpModal" class="modal">
    <h3>Level Up!</h3>
    <p id="statPointsInfo"></p>
    <p>Choose a stat to improve:</p>
    <div class="stat-choice tooltip" onclick="allocatePoint('strength')">
        [+] Strength
        <span class="tooltiptext">Increase physical attack power</span>
    </div>
    <div class="stat-choice tooltip" onclick="allocatePoint('swordfighting')">
        [+] Swordfighting
        <span class="tooltiptext">Enhance defensive capabilities</span>
    </div>
    <div class="stat-choice tooltip" onclick="allocatePoint('life')">
        [+] Life
        <span class="tooltiptext">Increase maximum health</span>
    </div>
    <div class="stat-choice tooltip" onclick="allocatePoint('willpower')">
        [+] Willpower
        <span class="tooltiptext">Resist sword's control but gain better bonuses</span>
    </div>
</div>

<!-- Game Sections -->
<div id="gameLogo" class="game-section">
    <img src="BSBTitles6.webp" class="logo-img" alt="Cursed Sword Legacy">
</div>

<div id="swordSection" class="game-section">
    <div id="swordStats">
        <h2>Sword Upgrades</h2>
        <div class="stat tooltip">
            Energy: <span id="energy">0</span>/<span id="maxEnergy">100</span>
            <span class="tooltiptext">Current/Maximum energy stored in the sword</span>
        </div>
        <div class="stat tooltip">
            Total Kills: <span id="totalKills">0</span>
            <span class="tooltiptext">Total number of enemies defeated</span>
        </div>
    </div>
    <div id="upgrades"></div>
</div>

<div id="zonesSection" class="game-section">
    <h2>Zones</h2>
    <div id="enemies"></div>
</div>

<div id="wielderSection" class="game-section">
    <h2>Wielder</h2>
    <div id="wielderStats"></div>
</div>

<div id="actionsSection" class="game-section">
    <h2>üéÆ Actions</h2>
    <div class="action-buttons">
            <span class="tooltip">
                <button id="restButton" onclick="onActionButtonClick('resting')">Rest</button>
                <span class="tooltiptext">Recover health faster (disables other actions)</span>
            </span>
        <span class="tooltip">
                <button id="trainButton" onclick="onActionButtonClick('training')">Train</button>
                <span class="tooltiptext">Gain 2 EXP/second (disables other actions)</span>
            </span>
        <span class="tooltip">
                <button onclick="healWielder()">Heal wielder (10 energy)</button>
                <span class="tooltiptext">Restore 25% health for 10 energy</span>
            </span><br>
        <span class="tooltip">
                <button onclick="showRaceSelection()">Change Wielder (Cost: 10 energy)</button>
                <span class="tooltiptext">Lose your current wielder permanently. Pick the race of a new one.</span>
            </span>

    </div>
</div>

<div id="combatLog" class="game-section combat-window">
    <h2>Combat Log</h2>
    <div id="combat-log" class="combat-log"></div>
</div>

<!-- Footer -->
<footer>
        <span class="tooltip">
            <a href="#" onclick="showStory()">üìñ</a>
            <span class="tooltiptext">View Sword's Story</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="showStatistics()">üìä</a>
            <span class="tooltiptext">Game Statistics</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="showChangelog()">üìú</a>
            <span class="tooltiptext">View Changelog</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="wipeSave()">‚ùå</a>
            <span class="tooltiptext">Delete Save File</span>
        </span>
    <span class="tooltip">
            <a href="#" onclick="showOptions()">‚öôÔ∏è</a>
            <span class="tooltiptext">Game Options</span>
        </span>
    <span class="tooltip">
            <a href="https://caffeineforge.com" target="_blank">üêô</a>
            <span class="tooltiptext">Visit Writer's Site</span>
    </span>
    <span class="tooltip">
            <a href="https://www.royalroad.com/fiction/106967/bloodstained-blade-gamelit-sword-mc" target="_blank">üê¶</a>
            <span class="tooltiptext">Read the Story</span>
        </span>
</footer>

<script>


        let lastUsedZoneIndex = 0;
        const game = {
            isFighting: false,
            autoBattle: false,
            currentEnemy: null,
            controlBonus: 0,
            sword: {
                energy: 0,
                maxEnergy: 100,
                kills: 0,
                upgrades: {
                    capacity: { level: 1, cost: 50 },
                    siphon: { level: 1, cost: 100 },
                    senses: { level: 1, cost: 200 },
                    connection: { level: 1, cost: 150 },
                    control: { level: 1, cost: 300 },
                    soul: { level: 1, cost: 500 }
                }
            },
            wielder: null,
            statistics: {
                totalKills: 0,
                wieldersUsed: 0,
                mobKills: {},
                zoneKills: {}
            },
            story: [],
            unlockedUpgrades: [],
            unlockedRaces: ['human']
        };
        let gameData, races, zones, upgradeCaps;
        game.currentAction = null;

        // Wielder Generation
        function generateWielder(race) {
            game.statistics.wieldersUsed = (game.statistics.wieldersUsed ?? 0) + 1;
            if (!race) {
                const availableRaces = Object.keys(races).filter(r => races[r].unlocked);
                race = availableRaces[Math.floor(Math.random() * availableRaces.length)];
            }
            const raceData = races[race];
            const baseStats = {
                strength: Math.floor(Math.random() * 6 + 1) + (raceData.stats.strength || 0),
                swordfighting: Math.floor(Math.random() * 6 + 1) + (raceData.stats.swordfighting || 0),
                life: Math.floor(Math.random() * 11 + 10) + (raceData.stats.life || 0),
                willpower: Math.floor(Math.random() * 50 + 50) + (raceData.stats.willpower || 0)
            };
            return {
                name: raceData.names[Math.floor(Math.random() * raceData.names.length)],
                race,
                baseStats: { ...baseStats },
                currentStats: { ...baseStats },
                wounds: [],
                level: 1,
                statPoints: 0,
                exp: 0,
                currentLife: baseStats.life,
                resting: false,
                training: false,
                defeated: false
            };
        }

        // Action Handling
        function onActionButtonClick(actionType) {
            const buttons = ['restButton', 'trainButton'];
            buttons.forEach(id => document.getElementById(id).classList.remove('active-action'));

            switch (actionType) {
                case 'resting':
                    game.currentAction = game.currentAction === 'resting' ? null : 'resting';
                    if (game.currentAction) document.getElementById('restButton').classList.add('active-action');
                    break;
                case 'training':
                    game.currentAction = game.currentAction === 'training' ? null : 'training';
                    if (game.currentAction) document.getElementById('trainButton').classList.add('active-action');
                    break;

            }
            updateDisplay();
        }

        function startAutoBattle() {
    if (!isAnyModalOpen()) {
        if (!gameData.zones[lastUsedZoneIndex]) lastUsedZoneIndex = 0;
        const zone = gameData.zones[lastUsedZoneIndex];
        const enemyIndex = Math.floor(Math.random() * zone.enemies.length);
        attackEnemy(lastUsedZoneIndex, enemyIndex);
    }
}

        function healWielder() {
            if (game.sword.energy >= 10 && game.wielder.currentLife < game.wielder.currentStats.life) {
                game.sword.energy -= 10;
                game.wielder.currentLife = Math.min(
                    game.wielder.currentLife + Math.floor(game.wielder.currentStats.life * 0.25),
                    game.wielder.currentStats.life
                );
                updateDisplay();
            }
        }

        // Display Updates
        function getWoundText(stat) {
            const count = game.wielder.wounds.filter(w => w === stat).length;
            return count > 0 ? `\n(Wounded: -${count})` : '';
        }
function updateCombatStats() {
    const wielder = game.wielder;

    // Update HP
    const hpElement = document.querySelector('#wielderStats .stat:nth-child(5)'); // Assuming HP is 5th stat
    if (hpElement) {
        hpElement.innerHTML = `
            HP: ${Math.max(wielder.currentLife, 0)}/${wielder.currentStats.life}
            <span class="tooltiptext">Current/Maximum health (Regenerates 1 HP every 5s)</span>
        `;
    }

    // Update EXP
    const expElement = document.querySelector('#wielderStats .stat:nth-child(7)'); // Assuming EXP is 7th stat
    if (expElement) {
        expElement.innerHTML = `
            EXP: ${Math.round(wielder.exp)}/${wielder.level * 100}
            <span class="tooltiptext">Gain a level every 100 exp points</span>
        `;
    }

    // Update Energy
    document.getElementById('energy').textContent = Math.floor(game.sword.energy);

    // Update Total Kills
    document.getElementById('totalKills').textContent = game.statistics.totalKills;
}
        function updateDisplay() {

            const wielder = game.wielder;
            const baseDamage = wielder.currentStats.strength * 2 + wielder.currentStats.swordfighting;
            const siphonBonus = game.sword.upgrades.siphon.level;
            const totalDamage = baseDamage + siphonBonus;
            game.controlBonus = game.sword.upgrades.control.level * 0.2 * (1 - Math.min(wielder.currentStats.willpower, 200) / 200);
            document.getElementById('wielderStats').innerHTML = `
                <div class="stat">Name: <span id="wielderName">${wielder.name}</span></div>
                <div class="stat">Race: <span id="wielderRace">${wielder.race}</span></div>
                <div class="stat tooltip">
                    Strength: ${wielder.currentStats.strength}${wielder.baseStats.strength > wielder.currentStats.strength ? '‚ö†' : ''}
                    <span class="tooltiptext">Increases damage dealt per strike (+2 Damage)${getWoundText('strength')}</span>
                </div><br />
                <div class="stat tooltip">
                    Swordfighting: ${wielder.currentStats.swordfighting}${wielder.baseStats.swordfighting > wielder.currentStats.swordfighting ? '‚ö†' : ''}
                    <span class="tooltiptext">Reduces incoming damage (+1 resistance) Increases damage (+1)${getWoundText('swordfighting')}</span>
                </div><br />
                <div class="stat tooltip">
                    HP: ${Math.max(wielder.currentLife, 0)}/${wielder.currentStats.life}
                    <span class="tooltiptext">Current/Maximum health (Regenerates 1 HP every 5s)</span>
                </div><br />
                <div class="stat tooltip">
                    Willpower: ${wielder.currentStats.willpower}${wielder.baseStats.willpower > wielder.currentStats.willpower ? '‚ö†' : ''}
                    <span class="tooltiptext">Increases exp gain, reduces control (up to 100% at 200)${getWoundText('willpower')}</span>
                </div><br />
                <div class="stat tooltip">
                    EXP: ${Math.round(wielder.exp)}/${wielder.level * 100}
                    <span class="tooltiptext">Gain a level every 100 exp points</span>
                </div><br />
                <div class="stat tooltip">
                    Level: ${wielder.level}
                </div><br />
                <div class="stat tooltip">
                    Predicted Damage: ${totalDamage.toFixed(1)}
                    <span class="tooltiptext">
                        Base: ${baseDamage} (Strength: ${wielder.currentStats.strength} √ó 2 + Swordfighting: ${wielder.currentStats.swordfighting})<br>
                        Control Bonus: +${(baseDamage * game.controlBonus).toFixed(1)} (${(game.controlBonus * 100).toFixed(0)}%)<br>
                        Lifesteal: +${game.sword.upgrades.siphon.level} damage & HP per hit
                    </span>
                </div>
            `;

            document.getElementById('energy').textContent = Math.floor(game.sword.energy);
            document.getElementById('maxEnergy').textContent = game.sword.maxEnergy;
            document.getElementById('totalKills').textContent = game.statistics.totalKills;

            document.getElementById('upgrades').innerHTML = Object.entries(game.sword.upgrades)
                .map(([name, data]) => `
                    <div class="upgrade tooltip">
                        ${name.charAt(0).toUpperCase() + name.slice(1)} (Level ${data.level})
                        <span class="tooltiptext">${getUpgradeTooltip(name)}</span>
                        <button onclick="buyUpgrade('${name}')" ${game.sword.energy >= data.cost ? '' : 'disabled'}>
                            Upgrade (${Math.round(data.cost)} energy)
                        </button>
                    </div>
                `)
                .join('');

            document.getElementById('enemies').innerHTML = gameData.zones
    .filter(zone => zone.unlocked)
    .map((zone, zi) => `
        <div class="zone">
            <h4>${zone.name}</h4>
            <span class="tooltip">
                            <button class="explore-btn" onclick="exploreZone(${zi})">Explore</button>
                            <span class="tooltiptext">
                                Possible enemies:<br>
                                ${zone.enemies.map(e => `${e.name} (Lv. ${e.level}, ${e.life} HP)`).join('<br>')}
                            </span>
                        </span>
            <span class="autofight">
                <input type="checkbox" id="auto-${zi}" onchange="toggleAutoFight(${zi})"
                    ${game.currentAction === 'autoFighting' && lastUsedZoneIndex === zi ? 'checked' : ''}
                    ${game.sword.upgrades.connection.level < zi + 1 || (game.currentAction && game.currentAction !== 'autoFighting') ? 'disabled' : ''}>
                <label for="auto-${zi}">Auto explore</label>
            </span>

        </div>
    `)
    .join('');

            const actionInProgress = !!game.currentAction;
            document.querySelectorAll('#enemies button').forEach(btn => {
                btn.disabled = actionInProgress || game.wielder.defeated;
            });


        }
// Explore Zone Logic
        function exploreZone(zoneIndex) {
            if (game.currentAction && game.currentAction !== 'autoFighting') return;
            lastUsedZoneIndex = zoneIndex;
            const enemyIndex = Math.floor(Math.random() * gameData.zones[zoneIndex].enemies.length);
            attackEnemy(zoneIndex, enemyIndex);
        }

        // Toggle Autofight
        function toggleAutoFight(zoneIndex) {
            const checkbox = document.getElementById(`auto-${zoneIndex}`);
            if (checkbox.checked) {
                gameData.zones.forEach((_, i) => {
                    if (i !== zoneIndex && document.getElementById(`auto-${i}`) != null) document.getElementById(`auto-${i}`).checked = false;
                });
                game.currentAction = 'autoFighting';
                lastUsedZoneIndex = zoneIndex;

                startAutoBattle();
            } else {
                game.currentAction = null;

            }
            updateDisplay();
        }
        function getUpgradeTooltip(name) {
            const tooltips = {
                capacity: 'Increases maximum energy',
                siphon: 'Adds 1 lifesteal per level',
                senses: 'Unlocks stronger enemies',
                connection: 'Improves bond with the wielder, unlocks additional mechanics, increases passive health regen',
                control: 'Increases damage bonus (20% at 0 willpower, 0% at 200+ willpower per level)',
                soul: 'Discover more of your history'
            };
            return tooltips[name] || '';
        }

        // Combat Logic
        function calculateExpGain(baseExp) {
            const enemy = gameData.zones[game.currentEnemy.zoneIndex].enemies[game.currentEnemy.enemyIndex];
            const levelDiff = enemy.level - game.wielder.level;
            const expMultiplier = 1 + (levelDiff * 0.2);
            const expGained = Math.max(Math.floor(baseExp * expMultiplier), 0) * (1 + game.wielder.currentStats.willpower / 200);
            addCombatMessage(`Gained ${expGained.toFixed(1)} exp. ${(expMultiplier * 100).toFixed(2)}% of base due to level gap.`, 'player-stat');
            return expGained;
        }

        async function attackEnemy(zoneIndex, enemyIndex) {
            if (game.currentAction && game.currentAction !== 'autoFighting') return;
            lastUsedZoneIndex = zoneIndex;
            const wielder = game.wielder;
            game.isFighting = true;
            game.currentEnemy = { zoneIndex, enemyIndex };
            const enemy = gameData.zones[zoneIndex].enemies[enemyIndex];
            let enemyLife = enemy.life;

            if (wielder.currentLife <= 0) {
                addCombatMessage('Wielder is too injured to fight!', 'damage');
                game.isFighting = false;
                updateDisplay();
                return;
            }

            const controlLevel = game.sword.upgrades.control.level;
            const willpower = Math.min(wielder.currentStats.willpower, 200); // Cap at 200
            game.controlBonus = controlLevel * 0.2 * (1 - willpower / 200); // 20% at 0 willpower, 0% at 200+

            const baseDamage = wielder.currentStats.strength * 2 + wielder.currentStats.swordfighting;
    const controlDamageBonus = baseDamage * game.controlBonus;
    const lifesteal = game.sword.upgrades.siphon.level; // 1 lifesteal per level
    const totalDamage = baseDamage + controlDamageBonus;

    addCombatMessage(`Engaging ${enemy.name} (${enemy.life} HP)`, 'player-stat');

    while (enemyLife > 0 && wielder.currentLife > 0 && !isAnyModalOpen()) {
        const damageDealt = Math.min(totalDamage, enemyLife);
        const lifestealHealing = Math.min(lifesteal, enemyLife); // Can't heal more than damage dealt
        enemyLife -= damageDealt;
        wielder.currentLife = Math.min(
            wielder.currentStats.life,
            wielder.currentLife + lifestealHealing
        );

        addCombatMessage(
            `Dealt ${damageDealt.toFixed(1)} damage (Base: ${baseDamage}, Control: ${controlDamageBonus.toFixed(1)}) ` +
            `Lifesteal: +${lifestealHealing} HP | Enemy HP: ${enemyLife}`,
            'damage'
        );

                await new Promise(resolve => setTimeout(resolve, 500));
            }
            if (isAnyModalOpen()) {
        addCombatMessage('Combat paused due to open menu.', 'player-stat');
        game.isFighting = false; // Reset fighting state
        return;
    }

            if (enemyLife <= 0) {
                const energyGain = enemy.life * (1 + game.sword.upgrades.siphon.level * 0.1);
                game.sword.energy = Math.min(game.sword.energy + energyGain, game.sword.maxEnergy);
                addCombatMessage(`${enemy.name} defeated! +${energyGain.toFixed(1)} energy`, 'enemy-defeated');

                const expGained = calculateExpGain(enemy.exp);
                wielder.exp += expGained;
                game.statistics.zoneKills[zoneIndex] = (game.statistics.zoneKills[zoneIndex] ?? 0) + 1;
                game.statistics.totalKills = (game.statistics.totalKills ?? 0) + 1;
                game.statistics.mobKills[enemy.name] = (game.statistics.mobKills[enemy.name] ?? 0) + 1;

                while (wielder.exp >= wielder.level * 100) {
                    wielder.exp -= wielder.level * 100;
                    wielder.level++;
                    wielder.statPoints += calculateStatPointsPerLevel();
                    applyLevelBonuses(); // Apply race-specific bonuses
                    showLevelUpModal();
                }
                game.isFighting = false;
                if (game.currentAction === 'autoFighting') startAutoBattle();
            }

            if (wielder.currentLife <= 0) {
                addCombatMessage('Lost the fight! Disengaging. Rest or heal.', 'damage');
                applyHeavyWound();
                if (game.currentAction === 'autoFighting') onActionButtonClick('autoFighting');
                game.isFighting = false;
            }
            updateDisplay();
        }
        function isAnyModalOpen() {
    const modals = [
        'raceSelectionModal',
        'unlocksModal',
        'statsModal',
        'optionsModal',
        'storyModal',
        'changelogModal',
        'levelUpModal'
    ];
    return modals.some(id => document.getElementById(id).style.display === 'block');
}
        function calculateStatPointsPerLevel() {
            const controlLevel = game.sword.upgrades.control.level;
            return 1 + controlLevel;
        }
        // Level Up
        function showLevelUpModal() {
            updateStatPointsInfo();
            document.getElementById('levelUpModal').style.display = 'block';
        }
        function applyLevelBonuses() {
            const race = game.wielder.race;
            const levelBonuses = gameData.races[race].levelBonuses || {};
            for (const [stat, bonus] of Object.entries(levelBonuses)) {
                game.wielder.currentStats[stat] += bonus;
                if (stat === 'life') {
                    game.wielder.currentLife += bonus; // Increase current HP when max HP increases
                }
            }
        }
        function allocatePoint(stat) {
            const wielder = game.wielder;
            wielder.currentStats[stat]++;
            wielder.statPoints--;
            if (stat === 'life') {
                wielder.currentStats.life += 4;
                wielder.currentLife += 5;
            }

            if (stat === 'willpower') wielder.currentStats.willpower += 4;
            if (wielder.statPoints <= 0) document.getElementById('levelUpModal').style.display = 'none';
            updateStatPointsInfo();
            updateDisplay();
        }

        // UI Functions
        function showRaceSelection() {
            const modal = document.getElementById('raceSelectionModal');
            gameData.zones = gameData.zones.map((zone, index) => ({
                ...zone,
                unlockRace: Object.keys(races).find(race => races[race].unlockRequirement?.zone === index)
            }));

            let content = '<div class="race-list">';
            Object.entries(races).forEach(([raceKey, raceData]) => {
                const zone = gameData.zones[raceData.unlockRequirement?.zone];
                const kills = raceData.unlockRequirement ? (game.statistics.zoneKills[raceData.unlockRequirement.zone] || 0) : 0;
                const required = raceData.unlockRequirement?.kills || 0;
                raceData.unlocked = raceData.unlocked || kills >= required; // Ensure unlocked status persists

                const baseRanges = {
                    strength: { min: 1, max: 6 },
                    swordfighting: { min: 1, max: 6 },
                    life: { min: 10, max: 20 },
                    willpower: { min: 75, max: 125 }
                };
                const statRanges = ['strength', 'swordfighting', 'life', 'willpower'].map(stat => {
                    const bonus = raceData.stats[stat] || 0;
                    const levelBonus = raceData.levelBonuses?.[stat] || 0;
                    const base = baseRanges[stat];
                    return { stat, min: base.min + bonus, max: base.max + bonus, levelBonus };
                });

                // Conditionally apply .tooltip class only if the race is unlocked
                const tooltipClass = raceData.unlocked ? 'tooltip' : '';

                content += `
                    <div onclick="selectRace('${raceKey}')" class="race-option ${raceData.unlocked ? '' : 'locked'} ${tooltipClass}">
                        <h4>${raceKey.toUpperCase()}</h4>
                        <div class="stats">
                            ${statRanges.map(({ stat, min, max, levelBonus }) => `
                                ${stat}: ${min}-${max} (+${levelBonus}/lvl)
                            `).join(' | ')}
                        </div>
                        ${!raceData.unlocked ? `
                            <div class="unlock-requirement">
                                ${required} ${zone?.name} kills (${kills}/${required})
                            </div>
                        ` : ''}
                        ${raceData.unlocked ? `
                            <span class="tooltiptext">
                                Starting ranges and per-level bonuses:<br>
                                ${statRanges.map(({ stat, min, max, levelBonus }) => `
                                    ${stat}: ${min}-${max} (Base: ${baseRanges[stat].min}-${baseRanges[stat].max}, Bonus: ${raceData.stats[stat] || 0}) +${levelBonus}/level
                                `).join('<br>')}
                            </span>
                        ` : ''}
                    </div>
                `;
            });
            content += '</div>';
            document.getElementById('raceOptions').innerHTML = content;
            modal.style.display = 'block';
            adjustTooltipPosition(); // Ensure tooltips are positioned correctly after rendering
        }

        function selectRace(race) {
            if (game.sword.energy >= 10 && gameData.races[race].unlocked) {
                game.sword.energy -= 10;
                game.wielder = generateWielder(race);
                document.getElementById('raceSelectionModal').style.display = 'none';
                updateDisplay();
            }
        }

        function showStatistics() {
            document.getElementById('statisticsContent').innerHTML = `
                <p>Total Kills: ${game.statistics.totalKills}</p>
                <p>Wielders Used: ${game.statistics.wieldersUsed}</p>
                <h4>Kills by Enemy:</h4>
                ${Object.entries(game.statistics.mobKills).map(([mob, count]) => `<p>${mob}: ${count}</p>`).join('')}
            `;
            document.getElementById('statsModal').style.display = 'block';
        }

        function addCombatMessage(text, className) {
            const logElement = document.createElement('div');
            logElement.className = `log-entry ${className}`;
            logElement.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
            const combatLog = document.getElementById('combat-log');
            combatLog.appendChild(logElement);
            if (combatLog.children.length > 50) combatLog.removeChild(combatLog.firstChild);
            combatLog.scrollTop = combatLog.scrollHeight;
        }
        function updateStatPointsInfo() {
            const controlLevel = game.sword.upgrades.control.level; // Assuming control upgrade is stored here
            const controlBonus = controlLevel ; // +1 stat point per 5 control levels
            const totalPoints = game.wielder.statPoints; // Current stat points to allocate
            const info = `You have ${totalPoints} stat points to allocate. ` +
                         `(Each level grants 1 base point + ${controlBonus} from control bonus)`;
            document.getElementById('statPointsInfo').textContent = info;
        }
        // Upgrades and Story
        function buyUpgrade(upgradeName) {
            const cap = gameData.upgradeCaps[upgradeName];
            const upgrade = game.sword.upgrades[upgradeName];
            if (upgrade.level >= cap) {
                addCombatMessage(`Maximum ${upgradeName} level reached!`, 'damage');
                return;
            }
            if (game.sword.energy >= upgrade.cost) {
                game.sword.energy -= upgrade.cost;
                upgrade.level++;
                upgrade.cost *= 2;
                if (upgradeName === 'capacity') game.sword.maxEnergy *= 2;
                if (upgradeName === 'senses') gameData.zones[upgrade.level - 1].unlocked = true;
                if (upgradeName === 'soul') {
                    unlockNextStory();
                    showStory();
                }
                updateDisplay();
            }
        }

        function unlockNextStory() {
            const stories = gameData.story;
            const nextLockedStory = Object.entries(stories).find(([_, story]) => !story.unlocked);
            if (nextLockedStory) {
                const [storyKey] = nextLockedStory;
                stories[storyKey].unlocked = true;
                return true;
            }
            return false;
        }

        function showStory() {
            const stories = Object.values(gameData.story).filter(story => story.unlocked);
            document.getElementById('storyContent').innerHTML = stories.length > 0
                ? stories.map(story => `<div class="story-entry"><h4>${story.title}</h4><p>${story.entry.join('</p><p>')}</p></div>`).join('')
                : '<p>No story fragments unlocked yet</p>';
            document.getElementById('storyModal').style.display = 'block';
        }

        // Save System
        function saveGame() {
            const saveData = { game, wielder: game.wielder, timestamp: Date.now(), gameData };
            localStorage.setItem('cursedSwordSave', JSON.stringify(saveData));
        }

        function loadGame() {
            const saved = localStorage.getItem('cursedSwordSave');
            if (saved) {
                const saveData = JSON.parse(saved);
                Object.assign(game, saveData.game);
                game.wielder = saveData.wielder;
                gameData = saveData.gameData;
                const temp = game.currentAction;
                game.currentAction = null;
                onActionButtonClick(temp);
                game.currentAction = temp;
            } else {
                game.wielder = generateWielder(null);
            }
        }

        // Wound System
        function applyHeavyWound() {
            const stats = ['strength', 'swordfighting', 'willpower'];
            const affectedStat = stats[Math.floor(Math.random() * stats.length)];
            game.wielder.wounds.push(affectedStat);
            game.wielder.currentStats[affectedStat] = Math.max(
                game.wielder.baseStats[affectedStat] - game.wielder.wounds.filter(w => w === affectedStat).length,
                1
            );
            addCombatMessage(`Heavy wound inflicted! Permanent -1 to ${affectedStat}`, 'damage');
            updateDisplay();
        }

        // Footer Functions
        function showChangelog() {
            document.getElementById('changelogContent').innerHTML = `
                <p>v1.2 - Added Save System & Wounds</p>
                <p>v1.1 - Zone Combat System</p>
                <p>v1.0 - Base Game</p>
            `;
            document.getElementById('changelogModal').style.display = 'block';
        }

        function wipeSave() {
            if (confirm('Permanently delete all progress?')) {
                localStorage.removeItem('cursedSwordSave');
                location.reload();
            }
        }

        function showOptions() {
            document.getElementById('optionsModal').style.display = 'block';
            document.getElementById('saveData').value = '';
        }

        function exportSave() {
            const saveData = { game, timestamp: Date.now(), version: 1.2 };
            document.getElementById('saveData').value = JSON.stringify(saveData, null, 2);
        }

        function importSave() {
            try {
                const importData = JSON.parse(document.getElementById('saveData').value);
                if (importData.version !== 1.2) throw new Error('Invalid version');
                Object.keys(game).forEach(key => {
                    if (importData.game[key]) game[key] = importData.game[key];
                });
                updateDisplay();
                alert('Save imported successfully!');
            } catch (e) {
                alert(`Import failed: ${e.message}`);
            }
        }

        // Game Initialization
        async function initGame() {
            gameData = await fetch('gameData.json').then(r => r.json());
            races = gameData.races;
            zones = gameData.zones;
            upgradeCaps = gameData.upgradeCaps;
            loadGame();
            saveGame();
            updateDisplay();

            setInterval(() => {
                if (game.wielder.currentLife < game.wielder.currentStats.life) {
                    const regenRate = game.currentAction === 'resting' ? 5 : 1;
                    game.wielder.currentLife = Math.min(
                        game.wielder.currentLife + regenRate,
                        game.wielder.currentStats.life
                    );
                }
                if (game.currentAction === 'training') {
                    game.wielder.exp += 5;
                    if (game.wielder.exp >= 100 * game.wielder.level) {
                        game.wielder.exp -= 100 * game.wielder.level;
                        game.wielder.level++;
                        game.wielder.statPoints += calculateStatPointsPerLevel();
                        applyLevelBonuses(); // Apply race-specific bonuses
                        showLevelUpModal();
                    }
                }
                updateDisplay();
                saveGame();
            }, 5000);
        }
function adjustTooltipPosition() {
            document.querySelectorAll('.tooltip').forEach(tooltip => {
                const tooltipText = tooltip.querySelector('.tooltiptext');
                if (!tooltipText) return;

                // Reset any inline styles from previous adjustments
                tooltipText.style.top = '';
                tooltipText.style.bottom = '';
                tooltipText.style.left = '50%';
                tooltipText.style.transform = 'translateX(-50%)';

                // Get bounding rectangles
                const tooltipRect = tooltipText.getBoundingClientRect();
                const triggerRect = tooltip.getBoundingClientRect();
                const viewportHeight = window.innerHeight;

                // Check if tooltip would be cut off above
                if (triggerRect.top - tooltipRect.height < 0) {
                    // Position below instead
                    tooltipText.style.top = 'calc(100% + 5px)';
                    tooltipText.style.bottom = 'auto';
                } else if (triggerRect.bottom + tooltipRect.height > viewportHeight) {
                    // Ensure it doesn't go below viewport bottom
                    tooltipText.style.bottom = 'calc(100% + 5px)';
                    tooltipText.style.top = 'auto';
                }

                // Adjust horizontal overflow
                if (tooltipRect.left < 0) {
                    tooltipText.style.left = '0';
                    tooltipText.style.transform = 'translateX(0)';
                } else if (tooltipRect.right > window.innerWidth) {
                    tooltipText.style.left = 'auto';
                    tooltipText.style.right = '0';
                    tooltipText.style.transform = 'translateX(0)';
                }
            });
        }

        // Call on load and whenever display updates might affect positioning
        window.onload = function() {
            initGame().then(() => {
                adjustTooltipPosition();
            });
        };

        // Hook into updateDisplay to adjust tooltips after UI changes
        const originalUpdateDisplay = updateDisplay;
        updateDisplay = function() {
            originalUpdateDisplay();
            adjustTooltipPosition();
        };
        window.onload = initGame;
    </script>
</body>
</html>
